<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS 中的锁概述</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/objectivec.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        document.addEventListener("DOMContentLoaded", () => {
            document.querySelectorAll("pre code").forEach((block) => {
                hljs.highlightElement(block);
            });
        });
        mermaid.initialize({ startOnLoad: true });
    </script>
    <script type="module" src="/mermaid-zoom.js"></script>
    <script src="/components/table-structure-component.js"></script>
    <script src="/table-structure-zoom.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const lockStructureData = {
                blocks: [
                    {
                        id: 'ios-locks',
                        title: 'iOS 中的锁',
                        rows: [
                            { offset: '按等待方式分类', size: '自旋锁 vs 互斥锁', linkTo: 'waiting-type' }
                        ]
                    },
                    {
                        id: 'waiting-type',
                        title: '按等待方式分类',
                        rows: [
                            { offset: '自旋锁（Busy Waiting）', size: 'CPU 持续检查锁状态，不进入睡眠', linkTo: 'spin-locks' },
                            { offset: '互斥锁（Sleep Waiting）', size: '线程进入睡眠，等待被唤醒', linkTo: 'mutex-locks' }
                        ]
                    },
                    {
                        id: 'spin-locks',
                        title: '自旋锁（Busy Waiting）',
                        rows: [
                            { offset: 'os_unfair_lock', size: 'iOS 10+ 推荐，高性能，替代 OSSpinLock' },
                            { offset: 'OSSpinLock', size: '已废弃（iOS 10+），存在优先级反转问题' }
                        ]
                    },
                    {
                        id: 'mutex-locks',
                        title: '互斥锁（Sleep Waiting）',
                        rows: [
                            { offset: 'pthread_mutex_t', size: 'POSIX 标准互斥锁，线程进入睡眠等待' },
                            { offset: 'NSLock', size: 'pthread_mutex_t 的 Objective-C 封装' },
                            { offset: 'dispatch_semaphore', size: 'GCD 信号量（值为1时作为锁使用）' }
                        ]
                    }
                ]
            };
            
            renderTableStructure(lockStructureData, 'lock-structure-container', { layout: 'hierarchical' });
        });
    </script>
</head>
<body>
    <div class="container wide">
        <h1>iOS 中的锁概述</h1>
        
        <h2>1. 什么是锁</h2>
        <p>锁（Lock）是一种同步机制，用于在多线程环境中保护共享资源，确保同一时刻只有一个线程能够访问被保护的代码区域（临界区）。</p>
        
        <h3>1.1 为什么需要锁</h3>
        <p>在多线程编程中，多个线程可能同时访问共享资源，导致：</p>
        <ul>
            <li><strong>数据竞争（Data Race）</strong>：多个线程同时读写同一数据，导致数据不一致</li>
            <li><strong>竞态条件（Race Condition）</strong>：程序执行结果依赖于线程执行的顺序</li>
            <li><strong>数据损坏</strong>：并发写入可能导致数据被破坏</li>
        </ul>
        
        <h2>2. iOS 中锁的整体结构</h2>
        
        <div id="lock-structure-container"></div>
        
        <h2>3. iOS 中常见的锁类型</h2>
        
        <table>
            <thead>
                <tr>
                    <th>锁类型</th>
                    <th>API</th>
                    <th>特点</th>
                    <th>性能</th>
                    <th>使用场景</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>互斥锁</strong></td>
                    <td><code class="highlight">pthread_mutex_t</code></td>
                    <td>不可重入，同一线程不能重复加锁</td>
                    <td>中等</td>
                    <td>一般同步场景</td>
                </tr>
                <tr>
                    <td><strong>递归锁</strong></td>
                    <td><code class="highlight">pthread_mutex_t</code> (PTHREAD_MUTEX_RECURSIVE)</td>
                    <td>可重入，同一线程可以多次加锁</td>
                    <td>中等</td>
                    <td>递归调用场景</td>
                </tr>
                <tr>
                    <td><strong>自旋锁</strong></td>
                    <td><code class="highlight">OSSpinLock</code> (已废弃)</td>
                    <td>忙等待，不进入睡眠</td>
                    <td>高（短时间等待）</td>
                    <td>等待时间短的场景（iOS 10+ 已废弃）</td>
                </tr>
                <tr>
                    <td><strong>信号量</strong></td>
                    <td><code class="highlight">dispatch_semaphore_t</code></td>
                    <td>可以控制并发数量</td>
                    <td>高</td>
                    <td>控制并发数量、生产者消费者</td>
                </tr>
                <tr>
                    <td><strong>读写锁</strong></td>
                    <td><code class="highlight">pthread_rwlock_t</code></td>
                    <td>读共享，写独占</td>
                    <td>高（读多写少）</td>
                    <td>读多写少的场景</td>
                </tr>
                <tr>
                    <td><strong>条件锁</strong></td>
                    <td><code class="highlight">NSCondition</code></td>
                    <td>可以等待条件满足</td>
                    <td>中等</td>
                    <td>生产者消费者、等待条件</td>
                </tr>
                <tr>
                    <td><strong>@synchronized</strong></td>
                    <td><code class="highlight">@synchronized(obj)</code></td>
                    <td>基于对象地址的递归锁</td>
                    <td>低</td>
                    <td>简单同步场景（性能要求不高）</td>
                </tr>
                <tr>
                    <td><strong>NSLock</strong></td>
                    <td><code class="highlight">NSLock</code></td>
                    <td>互斥锁的封装</td>
                    <td>中等</td>
                    <td>一般同步场景</td>
                </tr>
                <tr>
                    <td><strong>NSRecursiveLock</strong></td>
                    <td><code class="highlight">NSRecursiveLock</code></td>
                    <td>递归锁的封装</td>
                    <td>中等</td>
                    <td>递归调用场景</td>
                </tr>
                <tr>
                    <td><strong>os_unfair_lock</strong></td>
                    <td><code class="highlight">os_unfair_lock</code></td>
                    <td>iOS 10+ 替代 OSSpinLock</td>
                    <td>高</td>
                    <td>高性能场景</td>
                </tr>
            </tbody>
        </table>
        
        <h2>4. 锁的分类</h2>
        
        <h3>4.1 按是否可重入分类</h3>
        <table>
            <thead>
                <tr>
                    <th>类型</th>
                    <th>说明</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>不可重入锁</strong></td>
                    <td>同一线程不能重复加锁，否则会死锁</td>
                    <td><code class="highlight">pthread_mutex_t</code>（默认）、<code class="highlight">NSLock</code>、<code class="highlight">os_unfair_lock</code></td>
                </tr>
                <tr>
                    <td><strong>可重入锁（递归锁）</strong></td>
                    <td>同一线程可以多次加锁，需要相同次数的解锁</td>
                    <td><code class="highlight">pthread_mutex_t</code>（RECURSIVE）、<code class="highlight">NSRecursiveLock</code>、<code class="highlight">@synchronized</code></td>
                </tr>
            </tbody>
        </table>
        
        <h3>4.2 按等待方式分类</h3>
        <table>
            <thead>
                <tr>
                    <th>类型</th>
                    <th>等待方式</th>
                    <th>特点</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>自旋锁</strong></td>
                    <td>忙等待（Busy Waiting）</td>
                    <td>CPU 持续检查锁状态，不进入睡眠</td>
                    <td><code class="highlight">OSSpinLock</code>（已废弃）、<code class="highlight">os_unfair_lock</code></td>
                </tr>
                <tr>
                    <td><strong>互斥锁</strong></td>
                    <td>睡眠等待（Sleep Waiting）</td>
                    <td>线程进入睡眠，等待被唤醒</td>
                    <td><code class="highlight">pthread_mutex_t</code>、<code class="highlight">NSLock</code></td>
                </tr>
            </tbody>
        </table>
        
        <div class="info">
            <p><strong>自旋锁 vs 互斥锁</strong>：自旋锁适合等待时间短的场景（CPU 时间片内），互斥锁适合等待时间长的场景（避免 CPU 空转）。</p>
        </div>
        
        <h3>4.3 按功能分类</h3>
        <table>
            <thead>
                <tr>
                    <th>类型</th>
                    <th>功能</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>互斥锁</strong></td>
                    <td>保证同一时刻只有一个线程访问</td>
                    <td><code class="highlight">pthread_mutex_t</code>、<code class="highlight">NSLock</code></td>
                </tr>
                <tr>
                    <td><strong>读写锁</strong></td>
                    <td>读共享，写独占</td>
                    <td><code class="highlight">pthread_rwlock_t</code></td>
                </tr>
                <tr>
                    <td><strong>条件锁</strong></td>
                    <td>可以等待条件满足</td>
                    <td><code class="highlight">NSCondition</code>、<code class="highlight">NSConditionLock</code></td>
                </tr>
                <tr>
                    <td><strong>信号量</strong></td>
                    <td>控制并发数量</td>
                    <td><code class="highlight">dispatch_semaphore_t</code></td>
                </tr>
            </tbody>
        </table>
        
        <h2>5. 性能对比</h2>
        
        <p>根据实际测试（仅供参考，实际性能取决于具体场景）：</p>
        
        <table>
            <thead>
                <tr>
                    <th>锁类型</th>
                    <th>性能（相对）</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>os_unfair_lock</strong></td>
                    <td>⭐⭐⭐⭐⭐（最快）</td>
                    <td>iOS 10+ 推荐的高性能锁</td>
                </tr>
                <tr>
                    <td><strong>dispatch_semaphore</strong></td>
                    <td>⭐⭐⭐⭐</td>
                    <td>性能优秀，GCD 优化</td>
                </tr>
                <tr>
                    <td><strong>pthread_mutex</strong></td>
                    <td>⭐⭐⭐</td>
                    <td>性能中等，稳定可靠</td>
                </tr>
                <tr>
                    <td><strong>NSLock</strong></td>
                    <td>⭐⭐⭐</td>
                    <td>基于 pthread_mutex，性能相近</td>
                </tr>
                <tr>
                    <td><strong>NSRecursiveLock</strong></td>
                    <td>⭐⭐</td>
                    <td>递归锁性能略低</td>
                </tr>
                <tr>
                    <td><strong>@synchronized</strong></td>
                    <td>⭐（最慢）</td>
                    <td>性能最低，但使用简单</td>
                </tr>
            </tbody>
        </table>
        
        <div class="warning">
            <p><strong>性能提示</strong>：性能对比仅供参考，实际选择应该根据具体场景。对于大多数应用，性能差异可以忽略不计，应该优先考虑代码的可读性和维护性。</p>
        </div>
        
        <h2>6. 使用场景建议</h2>
        
        <table>
            <thead>
                <tr>
                    <th>场景</th>
                    <th>推荐锁</th>
                    <th>说明</th>
                    <th>不推荐</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>一般同步场景</strong></td>
                    <td><code class="highlight">pthread_mutex_t</code><br/><code class="highlight">NSLock</code><br/><code class="highlight">os_unfair_lock</code></td>
                    <td>性能好，稳定可靠</td>
                    <td><code class="highlight">@synchronized</code>（性能较低）</td>
                </tr>
                <tr>
                    <td><strong>递归调用场景</strong></td>
                    <td><code class="highlight">NSRecursiveLock</code><br/><code class="highlight">pthread_mutex_t</code>（RECURSIVE）</td>
                    <td>支持同一线程多次加锁</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td><strong>简单递归场景</strong></td>
                    <td><code class="highlight">@synchronized</code></td>
                    <td>代码简洁，易用</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td><strong>高性能场景</strong></td>
                    <td><code class="highlight">os_unfair_lock</code>（iOS 10+）</td>
                    <td>性能最优</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td><strong>高性能替代方案</strong></td>
                    <td><code class="highlight">dispatch_semaphore</code></td>
                    <td>值为 1 时作为锁使用，性能优秀</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td><strong>读多写少场景</strong></td>
                    <td><code class="highlight">pthread_rwlock_t</code></td>
                    <td>多个读操作可以并发执行，提高性能</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td><strong>控制并发数量</strong></td>
                    <td><code class="highlight">dispatch_semaphore_t</code></td>
                    <td>限制同时执行的线程数量</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td><strong>等待条件满足</strong></td>
                    <td><code class="highlight">NSCondition</code><br/><code class="highlight">NSConditionLock</code></td>
                    <td>生产者消费者模式、等待特定条件</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>
        
        <h2>7. 常见问题</h2>
        
        <h3>7.1 死锁问题</h3>
        <p><strong>原因</strong>：多个锁的加锁顺序不一致，导致循环等待</p>
        <div class="code-block"><code><span class="comment">// 错误示例：可能导致死锁</span>
<span class="comment">// 线程 A：先锁 lock1，再锁 lock2</span>
<span class="comment">// 线程 B：先锁 lock2，再锁 lock1</span>
<span class="comment">// 解决方案：统一加锁顺序</span></code></div>
        
        <h3>7.2 性能问题</h3>
        <p><strong>原因</strong>：锁的粒度太大，锁持有时间过长</p>
        <ul>
            <li>减小锁的粒度，只保护必要的代码</li>
            <li>减少锁持有时间，尽快释放锁</li>
            <li>避免在锁内执行耗时操作</li>
        </ul>
        
        <h3>7.3 优先级反转</h3>
        <p><strong>原因</strong>：低优先级线程持有锁，高优先级线程等待</p>
        <ul>
            <li>使用 <code class="highlight">os_unfair_lock</code> 可以缓解优先级反转问题</li>
            <li>避免长时间持有锁</li>
        </ul>
        
        <h2>7. 最佳实践</h2>
        
        <ol>
            <li><strong>选择合适的锁</strong>：根据场景选择最合适的锁类型</li>
            <li><strong>统一加锁顺序</strong>：避免死锁</li>
            <li><strong>减小锁粒度</strong>：只保护必要的代码</li>
            <li><strong>避免嵌套锁</strong>：减少死锁风险</li>
            <li><strong>及时释放锁</strong>：尽快释放锁，减少等待时间</li>
            <li><strong>避免在锁内执行耗时操作</strong>：如网络请求、文件 I/O 等</li>
            <li><strong>使用工具检测</strong>：使用 Thread Sanitizer 检测数据竞争</li>
        </ol>
        
        <h2>8. 总结</h2>
        
        <table>
            <thead>
                <tr>
                    <th>场景</th>
                    <th>推荐锁</th>
                    <th>原因</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>一般同步</td>
                    <td><code class="highlight">os_unfair_lock</code> 或 <code class="highlight">pthread_mutex_t</code></td>
                    <td>性能好，稳定可靠</td>
                </tr>
                <tr>
                    <td>递归调用</td>
                    <td><code class="highlight">NSRecursiveLock</code></td>
                    <td>支持重入，避免死锁</td>
                </tr>
                <tr>
                    <td>简单场景</td>
                    <td><code class="highlight">@synchronized</code></td>
                    <td>代码简洁，易用</td>
                </tr>
                <tr>
                    <td>读多写少</td>
                    <td><code class="highlight">pthread_rwlock_t</code></td>
                    <td>读操作并发，性能好</td>
                </tr>
                <tr>
                    <td>控制并发</td>
                    <td><code class="highlight">dispatch_semaphore_t</code></td>
                    <td>灵活控制并发数量</td>
                </tr>
                <tr>
                    <td>等待条件</td>
                    <td><code class="highlight">NSCondition</code></td>
                    <td>支持条件等待</td>
                </tr>
            </tbody>
        </table>
        
    </div>
</body>
</html>
