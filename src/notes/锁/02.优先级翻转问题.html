<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>优先级翻转问题</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/objectivec.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        document.addEventListener("DOMContentLoaded", () => {
            document.querySelectorAll("pre code").forEach((block) => {
                hljs.highlightElement(block);
            });
        });
        mermaid.initialize({ startOnLoad: true });
    </script>
    <script type="module" src="/mermaid-zoom.js"></script>
    <script src="/table-wrapper.js"></script>
</head>
<body>
    <div class="container wide">
        <h1>优先级翻转问题</h1>
        
        <h2>1. 什么是优先级翻转</h2>
        <p>优先级翻转（Priority Inversion）是操作系统调度中的一个异常现象：高优先级线程因为等待低优先级线程持有的资源，导致高优先级线程晚于低优先级线程（甚至中优先级线程）执行，违背了优先级调度的预期。</p>

        <h2>2. QoS：iOS 中的线程优先级</h2>
        <p>在 iOS/macOS 中，线程的优先级通过 <strong>QoS（Quality of Service，服务质量）</strong> 来标识。QoS 决定了线程的优先级，进而影响线程调度和优先级翻转问题。</p>

        <h3>2.1 QoS 的引入</h3>
        <p><strong>QoS 是在 iOS 8（2014年）中引入的</strong>，用于替代之前的数字优先级系统（如 <code>DISPATCH_QUEUE_PRIORITY_HIGH</code>、<code>DISPATCH_QUEUE_PRIORITY_LOW</code>）。</p>
        
        <table>
            <thead>
                <tr>
                    <th>时间点</th>
                    <th>变化</th>
                    <th>影响</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>iOS 8 之前</strong></td>
                    <td>使用数字优先级系统</td>
                    <td>优先级概念不够清晰</td>
                </tr>
                <tr>
                    <td><strong>iOS 8（2014年）</strong></td>
                    <td>引入 QoS 系统</td>
                    <td>使用语义化的 QoS 等级，更清晰地表达任务重要性，系统能更好地平衡性能和能耗</td>
                </tr>
                <tr>
                    <td><strong>iOS 8+</strong></td>
                    <td>调度器更严格地按 QoS 等级调度</td>
                    <td><code>OSSpinLock</code> 更容易出现优先级翻转问题</td>
                </tr>
                <tr>
                    <td><strong>iOS 10（2016年）</strong></td>
                    <td>推出 <code>os_unfair_lock</code>，支持优先级继承</td>
                    <td>解决 <code>OSSpinLock</code> 的优先级翻转问题</td>
                </tr>
            </tbody>
        </table>

        <h3>2.2 QoS 等级</h3>
        <p>iOS/macOS 定义了以下 QoS 等级（从高到低）：</p>
        
        <table>
            <thead>
                <tr>
                    <th>QoS 等级</th>
                    <th>说明</th>
                    <th>典型场景</th>
                    <th>优先级</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>User Interactive</strong></td>
                    <td>用户交互相关</td>
                    <td>UI 更新、动画、用户输入响应</td>
                    <td>最高</td>
                </tr>
                <tr>
                    <td><strong>User Initiated</strong></td>
                    <td>用户发起的任务</td>
                    <td>用户点击按钮后的操作</td>
                    <td>高</td>
                </tr>
                <tr>
                    <td><strong>Default</strong></td>
                    <td>默认优先级</td>
                    <td>一般任务</td>
                    <td>中等</td>
                </tr>
                <tr>
                    <td><strong>Utility</strong></td>
                    <td>实用工具类任务</td>
                    <td>后台处理、数据同步</td>
                    <td>低</td>
                </tr>
                <tr>
                    <td><strong>Background</strong></td>
                    <td>后台任务</td>
                    <td>数据备份、清理工作</td>
                    <td>最低</td>
                </tr>
            </tbody>
        </table>

        <h3>2.3 QoS 如何影响优先级翻转问题</h3>
        <p>QoS 通过以下方式影响优先级翻转问题：</p>
        
        <table>
            <thead>
                <tr>
                    <th>方面</th>
                    <th>说明</th>
                    <th>对优先级翻转的影响</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>严格的优先级调度</strong></td>
                    <td>iOS 的 Mach 内核采用严格的 QoS 调度算法，高 QoS 线程总是优先于低 QoS 线程获得 CPU</td>
                    <td>如果高 QoS 线程（H）在自旋等待，低 QoS 线程（L）可能无法获得 CPU，导致 L 被饿死</td>
                </tr>
                <tr>
                    <td><strong>QoS 不会降级</strong></td>
                    <td>iOS 内核不会允许高 QoS 线程降级到低 QoS。如果足够多的高 QoS 线程在自旋等待锁，持有锁的低 QoS 线程将永远无法执行</td>
                    <td>这是 OSSpinLock 在 iOS 上不安全的根本原因：高 QoS 线程自旋时，低 QoS 线程可能永远无法获得 CPU</td>
                </tr>
                <tr>
                    <td><strong>多核环境的不确定性</strong></td>
                    <td>在多核 CPU 上，低 QoS 线程可能在其他核心执行，但在单核或核心被关闭时，低 QoS 线程无法执行</td>
                    <td>iOS 无法保证多核环境始终可用，因此自旋锁可能导致程序卡死</td>
                </tr>
                <tr>
                    <td><strong>优先级继承的作用</strong></td>
                    <td><code>os_unfair_lock</code> 通过优先级继承，临时将低 QoS 线程提升到高 QoS 级别</td>
                    <td>即使高 QoS 线程在自旋，提升后的低 QoS 线程也能获得 CPU，避免被饿死</td>
                </tr>
            </tbody>
        </table>

        <div class="info">
            <p><strong>关键理解</strong>：QoS 是 iOS/macOS 中线程优先级的体现。优先级翻转问题的核心就是高 QoS 线程被低 QoS 线程阻塞，违背了 QoS 调度的预期。理解 QoS 有助于理解为什么自旋锁在 iOS 上不安全，以及为什么需要优先级继承机制。</p>
        </div>

        <h2>3. 锁的类型与优先级翻转</h2>
        <p>在 iOS/macOS 中，不同类型的锁对优先级翻转的影响不同，主要取决于锁的等待机制：</p>
        
        <table>
            <thead>
                <tr>
                    <th>锁类型</th>
                    <th>等待机制</th>
                    <th>触发问题所需线程数</th>
                    <th>产生的后果</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>自旋锁 (OSSpinLock)</strong></td>
                    <td>忙等待 (Busy Waiting)</td>
                    <td><strong>2 个线程</strong> (高+低)</td>
                    <td><strong>活锁 (Livelock) / 线程饥饿</strong> (程序可能卡死)</td>
                </tr>
                <tr>
                    <td><strong>互斥锁 (Mutex 等)</strong></td>
                    <td>睡眠等待 (Sleep)</td>
                    <td><strong>3 个线程</strong> (高+中+低)</td>
                    <td><strong>经典的优先级翻转</strong> (高优线程间接被中优阻塞)</td>
                </tr>
            </tbody>
        </table>

        <h2>4. 自旋锁的优先级翻转问题</h2>
        
        <h3>4.1 问题场景</h3>
        <p>假设系统中有两个线程：低优先级线程（L）和高优先级线程（H）。</p>
        <div class="code-block"><code><span class="comment">// 执行流程</span>
T1: L 获得自旋锁，进入临界区开始执行。
T2: H 被唤醒（例如处理紧急的用户交互），尝试获取同一个自旋锁。
T3: 因为锁正被 L 持有，H 获取失败，开始执行 while 循环（自旋忙等）。
T4: 问题发生。</code></div>

        <h3>4.2 单核 vs 多核：关键区别</h3>
        <p>自旋锁的行为在单核和多核环境下完全不同：</p>
        
        <table>
            <thead>
                <tr>
                    <th>场景</th>
                    <th>H 自旋时的行为</th>
                    <th>L 能否执行</th>
                    <th>结果</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>单核 CPU</strong></td>
                    <td>H 的 while 循环霸占唯一的 CPU</td>
                    <td>❌ 绝对分不到 CPU</td>
                    <td><strong>100% 的死锁/活锁</strong>：H 在等 L 释放锁，但 H 又霸占了 CPU，导致 L 永远无法执行</td>
                </tr>
                <tr>
                    <td><strong>多核 CPU</strong></td>
                    <td>H 在 Core 0 上自旋</td>
                    <td>✅ 可能在其他核心（如 Core 1）执行</td>
                    <td>如果 Core 1 空闲，L 可能执行完并释放锁。但<strong>无法保证 Core 1 永远有空，也无法保证系统不会为了省电关闭其他核心</strong></td>
                </tr>
            </tbody>
        </table>

        <div class="warning">
            <p><strong>为什么 iOS 认为 OSSpinLock 不安全？</strong></p>
            <p>因为 iOS 无法保证多核环境始终可用。系统可能为了省电关闭其他核心（低功耗模式），其他核心也可能被其他高优先级任务占用。一旦进入单核或核心被关闭的情况，自旋锁就会导致程序卡死。</p>
        </div>

        <h3>4.3 为什么 L 会被饿死？</h3>
        <p>iOS 使用的 Mach 内核采用<strong>严格的优先级调度算法</strong>。当内核决定把 CPU 时间片分给哪个线程时，它总是优先选择优先级最高且处于 <strong>Runnable（可运行）</strong> 状态的线程。</p>
        
        <table>
            <thead>
                <tr>
                    <th>因素</th>
                    <th>说明</th>
                    <th>影响</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>H 的状态</strong></td>
                    <td>H 在自旋等待时，并没有进入睡眠，状态始终是 <strong>Runnable</strong></td>
                    <td>H 始终处于可运行状态，调度器会考虑分配 CPU 给它</td>
                </tr>
                <tr>
                    <td><strong>优先级调度</strong></td>
                    <td>内核调度器会优先将 CPU 时间片分配给优先级更高的 H</td>
                    <td>在单核或核心被占用的情况下，L 被剥夺了 CPU 执行权</td>
                </tr>
                <tr>
                    <td><strong>结果</strong></td>
                    <td>L 无法执行完临界区代码并释放锁</td>
                    <td>H 永远等不到锁释放，程序卡死</td>
                </tr>
            </tbody>
        </table>

        <h2>5. 互斥锁的优先级翻转问题</h2>
        <p>对于互斥锁（如 <code>pthread_mutex</code>、<code>NSLock</code>、<code>dispatch_semaphore</code>），当获取不到锁时，线程会进入<strong>睡眠（Sleep）</strong>状态并主动让出 CPU。</p>

        <h3>5.1 两个线程的情况</h3>
        <p>如果只有高优先级线程（H）和低优先级线程（L）两个线程，互斥锁是安全的：</p>
        
        <table>
            <thead>
                <tr>
                    <th>时间点</th>
                    <th>H 的状态</th>
                    <th>L 的状态</th>
                    <th>结果</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>T1</td>
                    <td>尝试获取锁</td>
                    <td>持有锁，正在执行</td>
                    <td>H 获取失败</td>
                </tr>
                <tr>
                    <td>T2</td>
                    <td>进入睡眠（不再是 Runnable）</td>
                    <td>继续执行</td>
                    <td>CPU 分配给 L</td>
                </tr>
                <tr>
                    <td>T3</td>
                    <td>睡眠中</td>
                    <td>执行完毕，释放锁，唤醒 H</td>
                    <td>H 被唤醒，获得锁</td>
                </tr>
            </tbody>
        </table>

        <h3>5.2 三个线程的情况：经典的优先级翻转</h3>
        <p>互斥锁只有在引入一个<strong>中优先级线程（M）</strong>时，才会发生优先级翻转：</p>
        <div class="code-block"><code><span class="comment">// 经典的 3 线程优先级翻转流程</span>
T1: L 获得互斥锁，开始执行。
T2: H 尝试获取锁失败，进入【睡眠状态】，让出 CPU 给 L。
T3: 此时 M（中优先级，不需要任何锁）变为 Runnable 状态。
T4: 调度器比较当前 Runnable 的线程：M 的优先级 > L 的优先级。因此 CPU 时间片全部分给了 M。
T5: L 被 M 剥夺了执行权，由于没有 CPU，L 无法继续执行去释放锁。
T6: 处于睡眠中的 H 只能一直等下去，直到 M 执行完毕，L 才能重新获得 CPU 去释放锁。</code></div>

        <div class="info">
            <p><strong>结论：H 间接等待了 M。</strong></p>
            <p>最高优先级的 H，最终等待的时间变成了：<strong>L 的剩余执行时间 + M 的全部执行时间</strong>。这就是经典的优先级翻转问题。<br>但请注意，它<strong>不会导致活锁卡死</strong>，因为只要 M 执行完，L 总能继续执行并释放锁。系统依然是向前推进的。</p>
        </div>

        <h2>6. 解决方案：os_unfair_lock 与优先级继承</h2>
        <p>为了解决自旋锁的活锁问题和互斥锁的优先级翻转问题，苹果在 iOS 10 推出了 <code>os_unfair_lock</code> 作为 <code>OSSpinLock</code> 的替代。</p>
        
        <h3>6.1 os_unfair_lock 是什么类型的锁？</h3>
        <p><code>os_unfair_lock</code> <strong>不是纯自旋锁</strong>，而是一种<strong>自适应锁（Adaptive Lock）</strong>：</p>
        
        <table>
            <thead>
                <tr>
                    <th>场景</th>
                    <th>行为</th>
                    <th>原因</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>锁空闲时</strong></td>
                    <td>直接获取锁，无需等待</td>
                    <td>性能优秀</td>
                </tr>
                <tr>
                    <td><strong>锁被占用，持有者在核心上执行</strong></td>
                    <td>等待线程进行自适应自旋</td>
                    <td>锁可能很快释放，短暂自旋效率高</td>
                </tr>
                <tr>
                    <td><strong>锁被占用，竞争激烈或持有者不在核心上</strong></td>
                    <td>等待线程进入睡眠等待</td>
                    <td>避免长时间占用 CPU，类似互斥锁</td>
                </tr>
            </tbody>
        </table>
        <p>这种自适应设计既保证了低竞争场景下的高性能，又避免了纯自旋锁的活锁问题（不会一直自旋占用 CPU）。</p>
        <div class="info">
            <p><strong>说明</strong>：Apple 官方文档没有详细说明自旋和睡眠切换的具体阈值，这是系统内部的实现细节。但可以确定的是，<code>os_unfair_lock</code> 会根据实际情况在自旋和睡眠之间自适应切换，而不是像 <code>OSSpinLock</code> 那样一直自旋。</p>
        </div>
        
        <h3>6.2 优先级继承机制</h3>
        <p><code>os_unfair_lock</code> 与系统内核调度紧密结合，并利用了<strong>优先级继承（Priority Inheritance）</strong>机制：</p>
        
        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>解决的问题</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>H 发现锁被 L 持有并开始等待时，内核介入</td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>内核将 <strong>L 的优先级临时提升（继承）到与 H 相同的最高级别</strong></td>
                    <td>-</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>L 的优先级和 H 一样高</td>
                    <td><strong>解决互斥锁的 M 抢占问题：</strong>中优先级线程 M 无法再抢占 L 的 CPU，L 得以不受干扰地快速执行完临界区代码并释放锁</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>在多核环境下，L 更有可能被调度到空闲核心执行。如果等待时间过长，H 会进入睡眠</td>
                    <td><strong>解决自旋锁的活锁问题：</strong>避免浪费 CPU</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>锁释放后，L 的优先级恢复到原来的低级别，H 被唤醒获取锁执行</td>
                    <td>-</td>
                </tr>
            </tbody>
        </table>

        <h3>6.3 优先级继承与自适应机制的配合</h3>
        <p>优先级继承和自适应机制解决的是不同层面的问题：</p>
        <table>
            <thead>
                <tr>
                    <th>机制</th>
                    <th>解决的问题</th>
                    <th>作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>优先级继承</strong></td>
                    <td>L 被 M 抢占（3 线程场景）</td>
                    <td>临时提升 L 的优先级，避免被 M 抢占</td>
                </tr>
                <tr>
                    <td><strong>优先级继承</strong></td>
                    <td>L 被 H 饿死（2 线程场景，多核）</td>
                    <td>提升 L 的优先级，增加 L 被调度到空闲核心的概率</td>
                </tr>
                <tr>
                    <td><strong>自适应机制</strong></td>
                    <td>H 等待时的 CPU 效率</td>
                    <td>如果等待时间过长，H 进入睡眠，避免浪费 CPU</td>
                </tr>
            </tbody>
        </table>

        <h2>7. 常见问题</h2>
        
        <h3>7.1 优先级翻转是死锁吗？</h3>
        <p><strong>不是</strong>。优先级翻转和死锁是两个不同的概念：</p>
        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>死锁</th>
                    <th>优先级翻转</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>等待关系</strong></td>
                    <td>循环等待（A等B，B等A）</td>
                    <td>单向等待（H等L）</td>
                </tr>
                <tr>
                    <td><strong>能否恢复</strong></td>
                    <td>不能，需要外部干预</td>
                    <td>能，低优先级线程会释放锁</td>
                </tr>
                <tr>
                    <td><strong>阻塞时间</strong></td>
                    <td>永久阻塞</td>
                    <td>临时阻塞</td>
                </tr>
                <tr>
                    <td><strong>所需资源</strong></td>
                    <td>至少2个锁</td>
                    <td>1个锁</td>
                </tr>
            </tbody>
        </table>
        <p>虽然自旋锁导致的优先级翻转在表现上看起来像死锁一样卡死了程序，但它不是死锁，而是活锁（Livelock）或线程饥饿（Starvation）。</p>

        <h3>7.2 为什么 OSSpinLock 能用这么久才被废弃？</h3>
        <p>主要原因：</p>
        
        <table>
            <thead>
                <tr>
                    <th>原因</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>多核环境下可能工作</strong></td>
                    <td>在多核 CPU 上，如果其他核心有空闲，低优先级线程可能在其他核心执行，问题不会立即暴露</td>
                </tr>
                <tr>
                    <td><strong>问题不是必现的</strong></td>
                    <td>需要特定条件才会触发（单核或核心被关闭），很多场景下不会发生</td>
                </tr>
                <tr>
                    <td><strong>性能优势明显</strong></td>
                    <td>自旋锁性能优秀，在等待时间短的场景下表现很好</td>
                </tr>
                <tr>
                    <td><strong>替代方案不成熟</strong></td>
                    <td>早期没有更好的替代方案，直到 iOS 10 才推出 os_unfair_lock</td>
                </tr>
            </tbody>
        </table>

        <h2>8. 总结</h2>
        <table>
            <thead>
                <tr>
                    <th>锁类型</th>
                    <th>等待机制</th>
                    <th>引发翻转条件</th>
                    <th>严重程度</th>
                    <th>苹果官方态度</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>OSSpinLock</strong></td>
                    <td>纯用户态忙等待</td>
                    <td><strong>2 个线程</strong>即可触发（单核或核心被关闭时）</td>
                    <td>🔴 极其严重（活锁死局，CPU 100%浪费）</td>
                    <td>❌ 已废弃，严禁使用</td>
                </tr>
                <tr>
                    <td><strong>pthread_mutex / NSLock 等</strong></td>
                    <td>睡眠等待，让出 CPU</td>
                    <td>需要 <strong>3 个线程</strong>触发</td>
                    <td>🟡 中等（H 晚于 M 执行，产生延迟，但系统不瘫痪）</td>
                    <td>✅ 正常使用</td>
                </tr>
                <tr>
                    <td><strong>os_unfair_lock</strong></td>
                    <td>自适应机制 + 优先级继承</td>
                    <td><strong>系统自动解决</strong>（通过临时提升 L 的优先级）</td>
                    <td>🟢 安全、极速</td>
                    <td>✅ iOS 10+ 官方首推替代品</td>
                </tr>
            </tbody>
        </table>

    </div>
</body>
</html>
