<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>weak原理</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/objectivec.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ 
            startOnLoad: true
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        });
    </script>
    <script type="module" src="/mermaid-zoom.js"></script>
</head>
<body>
    <div class="container">
        <h1>weak原理</h1>
        
        <h2>概述</h2>
        <p>weak 关键字用于创建弱引用，不增加对象的引用计数。当对象被释放时，weak 引用会自动置为 nil。</p>
        
        <h2>weak 引用的实现流程</h2>
        <div class="mermaid">
flowchart TD
    A["创建 weak 引用<br/>weak var obj = target"] --> B["objc_storeWeak"]
    B --> C["查找 SideTable"]
    C --> D["在 weak_table_t 中查找<br/>或创建 weak_entry_t"]
    D --> E["将 weak 变量地址<br/>添加到 weak_entry_t"]
    
    F["对象释放"] --> G["objc_destructInstance"]
    G --> H["查找 SideTable"]
    H --> I["在 weak_table_t 中<br/>找到 weak_entry_t"]
    I --> J["遍历所有 weak 变量地址"]
    J --> K["将所有 weak 变量<br/>置为 nil"]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#fff4e1
    style D fill:#ccffcc
    style E fill:#ccffcc
    style F fill:#ffcccc
    style G fill:#fff4e1
    style H fill:#fff4e1
    style I fill:#ccffcc
    style J fill:#ccffcc
    style K fill:#ccffcc
        </div>
        
        <h2>关键步骤说明</h2>
        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. 创建 weak 引用</strong></td>
                    <td>objc_storeWeak</td>
                    <td>将 weak 变量地址注册到 SideTable 的 weak_table_t 中</td>
                </tr>
                <tr>
                    <td><strong>2. 查找/创建 weak_entry_t</strong></td>
                    <td>在 weak_table_t 中查找</td>
                    <td>通过对象地址（Key）查找对应的 weak_entry_t（Value），如果不存在则创建</td>
                </tr>
                <tr>
                    <td><strong>3. 添加 weak 变量地址</strong></td>
                    <td>append_referrer</td>
                    <td>将 weak 变量的地址添加到 weak_entry_t 的 Value 中（存储 weak 指针地址数组）</td>
                </tr>
                <tr>
                    <td><strong>4. 对象释放时</strong></td>
                    <td>objc_destructInstance</td>
                    <td>对象释放时，查找对应的 weak_entry_t</td>
                </tr>
                <tr>
                    <td><strong>5. 清空所有 weak 引用</strong></td>
                    <td>遍历 weak 变量地址</td>
                    <td>遍历 weak_entry_t 中存储的所有 weak 变量地址，将它们都置为 nil</td>
                </tr>
            </tbody>
        </table>
        
        <h2>核心代码逻辑</h2>
        
        <h3>创建 weak 引用</h3>
        <div class="code-block"><pre><code>// 伪代码：objc_storeWeak
void objc_storeWeak(id *location, id newObj) {
    // 1. 获取对象的 SideTable
    SideTable &table = SideTables()[newObj];
    
    // 2. 在 weak_table_t 中查找或创建 weak_entry_t
    weak_entry_t *entry = weak_entry_for_referent(table.weak_table, newObj);
    if (!entry) {
        // 创建新的 weak_entry_t
        entry = create_weak_entry(newObj);
        weak_table_insert(table.weak_table, entry);
    }
    
    // 3. 将 weak 变量地址添加到 weak_entry_t
    append_referrer(entry, location);  // location 是 weak 变量的地址
}</code></pre></div>
        
        <h3>对象释放时清空 weak 引用</h3>
        <div class="code-block"><pre><code>// 伪代码：对象释放时
void objc_destructInstance(id obj) {
    // 1. 获取对象的 SideTable
    SideTable &table = SideTables()[obj];
    
    // 2. 在 weak_table_t 中查找 weak_entry_t
    weak_entry_t *entry = weak_entry_for_referent(table.weak_table, obj);
    if (entry) {
        // 3. 遍历所有 weak 变量地址，将它们都置为 nil
        for (weak_referrer_t *referrer = entry->referrers; 
             referrer != NULL; 
             referrer++) {
            *referrer = nil;  // 将 weak 变量置为 nil
        }
        
        // 4. 从 weak_table_t 中移除该 weak_entry_t
        remove_referrer(entry);
    }
}</code></pre></div>
        
        <h2>关键理解</h2>
        <ul>
            <li><strong>weak 变量地址</strong>：weak 变量本身也有内存地址，这个地址被存储在 weak_entry_t 中</li>
            <li><strong>自动置 nil</strong>：对象释放时，通过 weak_entry_t 找到所有 weak 变量的地址，将这些地址存储的值改为 nil</li>
            <li><strong>不增加引用计数</strong>：weak 引用不会让对象的引用计数 +1，所以不会阻止对象释放</li>
            <li><strong>必须可选类型</strong>：因为可能为 nil，所以 weak 变量必须是可选类型</li>
        </ul>
        
        <h2>与 SideTable 的关系</h2>
        <p>weak 引用的实现依赖于 SideTable：</p>
        <ul>
            <li>SideTable 中的 <strong>weak_table_t</strong> 存储所有对象的 weak 引用信息</li>
            <li>通过对象地址（Key）查找对应的 <strong>weak_entry_t</strong>（Value）</li>
            <li>weak_entry_t 中存储了所有指向该对象的 weak 变量地址</li>
            <li>当对象释放时，通过这些地址将所有 weak 变量置为 nil</li>
        </ul>
    </div>
</body>
</html>
