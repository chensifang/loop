<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>loop</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/objectivec.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        document.addEventListener("DOMContentLoaded", () => {
            document.querySelectorAll("pre code").forEach((block) => {
                hljs.highlightElement(block);
            });
        });
        mermaid.initialize({ startOnLoad: true });
    </script>
    <script src="/table-wrapper.js"></script>
    <script src="/components/table-component.js"></script>
</head>
<body>
    <div class="container">
        <h1>T3：CATransaction Commit 阶段（提交到 Render Server）</h1>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>Display 阶段之后，RunLoop 进入休眠前</td>
                </tr>
                <tr>
                    <td><strong>触发时机</strong></td>
                    <td>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li>RunLoop 的 <code class="highlight">kCFRunLoopBeforeWaiting</code> 阶段</li>
                            <li>或者手动调用 <code class="highlight">CATransaction.commit()</code> 时</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>（见下方表格）</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. CATransaction 的作用</strong></td>
                    <td>事务机制</td>
                    <td>CATransaction 是 Core Animation 的事务机制；用于批量处理多个 Layer 的更新，统一提交到 Render Server；每个 RunLoop 周期会自动创建一个隐式事务</td>
                </tr>
                <tr>
                    <td><strong>2. 收集需要提交的 Layer</strong></td>
                    <td>收集标记</td>
                    <td>系统收集所有被标记为"需要提交"的 Layer；包括所有在 t0、t1、t2 阶段被修改的 Layer</td>
                </tr>
                <tr>
                    <td><strong>3. 三种 Layer 树</strong></td>
                    <td>构建树结构</td>
                    <td>Model Tree、Presentation Tree、Render Tree（见下方表格）</td>
                </tr>
                <tr>
                    <td><strong>4. 构建 Render Tree</strong></td>
                    <td>构建渲染树</td>
                    <td>根据 Model Tree（应用层的 Layer 树）构建 Render Tree；Render Tree 包含所有需要渲染的信息：几何属性、视觉属性、层级关系</td>
                </tr>
                <tr>
                    <td><strong>5. 序列化 Layer 数据</strong></td>
                    <td>序列化并发送</td>
                    <td>将 Render Tree 序列化成二进制数据；通过 IPC（进程间通信）发送到 Render Server（backboardd 进程）</td>
                </tr>
            </tbody>
        </table>

        <h2>三种 Layer 树</h2>

        <p>iOS 中有三种 Layer 树，它们在不同阶段发挥作用：</p>

        <table>
            <thead>
                <tr>
                    <th>树类型</th>
                    <th>存在时间</th>
                    <th>位置</th>
                    <th>作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Model Tree（模型树）</strong></td>
                    <td>t0 阶段开始，一直存在</td>
                    <td>应用进程内存中</td>
                    <td>存储 Layer 的最终状态（你设置的属性值）</td>
                </tr>
                <tr>
                    <td><strong>Presentation Tree（呈现树）</strong></td>
                    <td>动画进行时</td>
                    <td>应用进程内存中</td>
                    <td>存储动画的中间值，供应用层查询（如 <code class="highlight">layer.presentation()</code>）</td>
                </tr>
                <tr>
                    <td><strong>Render Tree（渲染树）</strong></td>
                    <td>t3 阶段构建，提交到 Render Server</td>
                    <td>Render Server 进程内存中</td>
                    <td>存储需要渲染的所有信息，用于实际渲染</td>
                </tr>
            </tbody>
        </table>

        <p><strong>三种树的关系</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>时间线</th>
                    <th>操作</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>t0-t2</strong></td>
                    <td>Model Tree（应用层设置属性）</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>根据 Model Tree 构建 Render Tree</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>Render Tree 序列化，发送到 Render Server</td>
                </tr>
                <tr>
                    <td><strong>t4+</strong></td>
                    <td>Render Server 使用 Render Tree 进行渲染</td>
                </tr>
                <tr>
                    <td><strong>动画时</strong></td>
                    <td>Model Tree（最终值） → Presentation Tree（中间值） → Render Tree（渲染）</td>
                </tr>
            </tbody>
        </table>

        <p><strong>这个阶段发生了什么（续）</strong>：</p>

        <ol>
            <li><strong>三种 Layer 树</strong>（见上方表格）</li>
        </ol>

        <p><strong>关键点</strong>：</p>
        <ul>
            <li>Commit 阶段不进行实际渲染，只是提交数据</li>
            <li>Render Server 是独立进程，与应用进程分离</li>
            <li>所有 Layer 的更新会批量提交，提高效率</li>
        </ul>

        <h2>动画和 RunLoop 的关系</h2>

        <p><strong>关键误解</strong>：动画的每一帧渲染不是由 RunLoop 驱动的！</p>

        <table>
            <thead>
                <tr>
                    <th>对比项</th>
                    <th>RunLoop</th>
                    <th>Render Server</th>
                    <th>VSync</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>提交时机</strong></td>
                    <td>休眠前会提交一次渲染（一次性提交，不是每帧都提交）</td>
                    <td>收到提交后持续渲染</td>
                    <td>每秒 60 次信号</td>
                </tr>
                <tr>
                    <td><strong>提交内容</strong></td>
                    <td>动画的开始状态和结束状态，以及动画参数（时长、曲线等）</td>
                    <td>根据动画参数计算每一帧的中间值</td>
                    <td>触发渲染信号</td>
                </tr>
                <tr>
                    <td><strong>驱动方式</strong></td>
                    <td>RunLoop 驱动</td>
                    <td>VSync 驱动</td>
                    <td>硬件驱动</td>
                </tr>
                <tr>
                    <td><strong>频率</strong></td>
                    <td>一次提交</td>
                    <td>60 次/秒</td>
                    <td>60 次/秒</td>
                </tr>
            </tbody>
        </table>

        <p><strong>动画时的流程</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>阶段</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>t0</strong></td>
                    <td>代码执行，设置动画</td>
                    <td>修改属性值</td>
                </tr>
                <tr>
                    <td><strong>t1-t2</strong></td>
                    <td>Layout 和 Display</td>
                    <td>如果需要</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>提交动画到 Render Server</td>
                    <td>提交起始值、结束值、动画参数，不是提交每一帧的值</td>
                </tr>
                <tr>
                    <td><strong>动画开始后（Render Server 端）</strong></td>
                    <td>VSync 信号触发</td>
                    <td>VSync 信号 1 → Render Server 计算第 1 帧的中间值 → GPU 渲染<br>VSync 信号 2 → Render Server 计算第 2 帧的中间值 → GPU 渲染<br>...</td>
                </tr>
            </tbody>
        </table>

        <h2>Presentation Tree 的真正作用</h2>

        <p><strong>核心结论</strong>：Render Server 才是计算中心</p>

        <p>动画开始后，App 进程只提交一次，剩下的活儿全是 Render Server 的：</p>
        <ol>
            <li><strong>App 进程（t3 阶段）</strong>：把动画的"剧本"（起始值、终点值、时长、插值曲线函数）打包成一个 <code class="highlight">CATransaction</code> 发送给 Render Server，只提交一次</li>
            <li><strong>Render Server（动画过程中）</strong>：它是独立进程，内部有一个由 VSync 驱动的计时器，每一帧根据"剧本"公式，自己计算出当前时刻位图应该在哪个坐标，直接命令 GPU 绘制，不依赖 App 进程的每帧计算</li>
            <li><strong>App 进程（动画过程中）</strong>：不需要参与每一帧的计算，即使主线程被卡死，动画依然会流畅地运行</li>
        </ol>

        <p><strong>Presentation Tree 的本质</strong>：它是一个"镜像查询接口"</p>
        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>计算时机</strong></td>
                    <td>它不是被主动"计算"出来提交的，而是当你访问 <code class="highlight">layer.presentation()</code> 时，UIKit 才去向 Render Server 询问（或者根据时间戳本地推算）</td>
                </tr>
                <tr>
                    <td><strong>主要用途</strong></td>
                    <td>主要用于处理交互，比如一个移动的按钮，你点击时，需要知道它此刻在屏幕的什么位置</td>
                </tr>
                <tr>
                    <td><strong>与 Render Server 的关系</strong></td>
                    <td>是 Render Server 中当前帧状态在 App 进程中的投影</td>
                </tr>
            </tbody>
        </table>

        <h2>两种动画的本质区别</h2>

        <table>
            <thead>
                <tr>
                    <th>对比项</th>
                    <th>Core Animation 动画（显式或隐式动画）</th>
                    <th>基于 CADisplayLink 的手动动画</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>提交次数</strong></td>
                    <td>1 次（提交剧本）</td>
                    <td>每秒 60/120 次</td>
                </tr>
                <tr>
                    <td><strong>执行者</strong></td>
                    <td>Render Server</td>
                    <td>App 进程（主线程）</td>
                </tr>
                <tr>
                    <td><strong>依赖关系</strong></td>
                    <td>不依赖 App 进程的每帧计算</td>
                    <td>App 进程每帧都计算和提交</td>
                </tr>
                <tr>
                    <td><strong>性能</strong></td>
                    <td>高效，即使主线程卡顿，动画依然流畅</td>
                    <td>非常消耗 CPU 性能</td>
                </tr>
                <tr>
                    <td><strong>例子</strong></td>
                    <td><code class="highlight">UIView.animate</code>、<code class="highlight">CABasicAnimation</code> 等</td>
                    <td>手动写了 <code class="highlight">CADisplayLink</code>，并在回调里每帧修改 <code class="highlight">view.center</code></td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>
