<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>loop</title>
    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/swift.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/objectivec.min.js"></script>
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        document.addEventListener("DOMContentLoaded", () => {
            document.querySelectorAll("pre code").forEach((block) => {
                hljs.highlightElement(block);
            });
        });
        mermaid.initialize({ startOnLoad: true });
    </script>
    <script src="/table-wrapper.js"></script>
    <script src="/components/table-component.js"></script>
    <style>
        /* 一级标题 - 主标题 */
        h1 {
            color: #1a1a1a;
        }
        
        /* 二级标题 - 主要章节（T0-T5） */
        h2 {
            color: #2563eb;
            margin-top: 30px;
        }
        
        /* 三级标题 - 子章节 */
        h3 {
            color: #059669;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>01. iOS 绘制流程</h1>
        
        <p>本文以 <code class="highlight">UIButton</code>（有文字 + 有图片）为例，详细说明从代码执行到屏幕显示的完整流程。</p>

        <p><code class="highlight">UIButton</code> 内部有多个子视图，对应多个 <code class="highlight">CALayer</code>：</p>
        
        <ul>
            <li><code class="highlight">UIButton</code> 自身 → 1 个 <code class="highlight">CALayer</code>（负责背景色、圆角等）</li>
            <li><code class="highlight">UIImageView</code>（内部图片视图）→ 1 个 <code class="highlight">CALayer</code></li>
            <li><code class="highlight">UILabel</code>（内部文字视图）→ 1 个 <code class="highlight">CALayer</code></li>
        </ul>
        
        <p>一个按钮背后是 3 个 <code class="highlight">CALayer</code> 在工作。</p>

        <table>
            <thead>
                <tr>
                    <th>Layer</th>
                    <th>显示方式</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>UIButton 自身的 Layer</strong></td>
                    <td>GPU 直接渲染</td>
                    <td>只设置了 <code class="highlight">backgroundColor</code>、<code class="highlight">cornerRadius</code> 等属性，没有 <code class="highlight">contents</code>，GPU 直接根据这些属性渲染几何图形</td>
                </tr>
                <tr>
                    <td><strong>UIImageView 的 Layer</strong></td>
                    <td>图片解码成 bitmap</td>
                    <td>图片文件（PNG/JPEG）从磁盘读取后需要解码成 bitmap，解码后的 bitmap 赋值给 <code class="highlight">layer.contents</code></td>
                </tr>
                <tr>
                    <td><strong>UILabel 的 Layer</strong></td>
                    <td>文字光栅化成 bitmap</td>
                    <td>文字通过 Core Text 排版，排版结果光栅化成 bitmap，bitmap 存入 <code class="highlight">layer.contents</code></td>
                </tr>
            </tbody>
        </table>

        <h2>1. T0：代码执行阶段（主线程）</h2>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>代码执行时，在主线程同步执行</td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>（见下方表格）</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. 创建 UIButton 对象</strong></td>
                    <td><code class="highlight">UIButton(type: .system)</code></td>
                    <td>在堆上分配内存；创建 UIButton 的 <code class="highlight">CALayer</code>（此时 <code class="highlight">contents</code> 为 nil）；创建内部的 <code class="highlight">UIImageView</code> 和 <code class="highlight">UILabel</code>（各自也有 <code class="highlight">CALayer</code>）</td>
                </tr>
                <tr>
                    <td><strong>2. 设置 frame</strong></td>
                    <td><code class="highlight">button.frame = ...</code></td>
                    <td>实际设置的是 <code class="highlight">layer.frame</code>；Layer 的 frame 属性被修改；此时还没有布局计算，只是属性值被设置</td>
                </tr>
                <tr>
                    <td><strong>3. 设置文字</strong></td>
                    <td><code class="highlight">button.setTitle(...)</code></td>
                    <td>内部 <code class="highlight">UILabel</code> 的 text 属性被设置；<code class="highlight">UILabel</code> 的 Layer 标记需要更新（内部调用类似 <code class="highlight">setNeedsDisplay</code>）；但此时还没有生成 bitmap</td>
                </tr>
                <tr>
                    <td><strong>4. 设置图片</strong></td>
                    <td><code class="highlight">button.setImage(...)</code></td>
                    <td>内部 <code class="highlight">UIImageView</code> 的 image 属性被设置；<code class="highlight">UIImageView</code> 的 Layer 标记需要更新；图片文件还在内存中，还没有解码成 bitmap</td>
                </tr>
                <tr>
                    <td><strong>5. 设置背景色和圆角</strong></td>
                    <td><code class="highlight">backgroundColor</code>、<code class="highlight">cornerRadius</code></td>
                    <td>Layer 的属性被设置；UIButton 自身的 Layer 标记需要更新</td>
                </tr>
                <tr>
                    <td><strong>6. 添加到视图层级</strong></td>
                    <td><code class="highlight">view.addSubview(button)</code></td>
                    <td>button 被添加到视图树；button 的 Layer 被添加到 Layer 树（Model Tree）；此时 Layer 树已经建立，但还没有渲染</td>
                </tr>
            </tbody>
        </table>

        <p><strong>关键点</strong>：</p>
        <ul>
            <li>这个阶段只修改属性值，不进行实际绘制</li>
            <li>所有 Layer 的 <code class="highlight">contents</code> 都还是 nil（或之前的值）</li>
            <li>系统只是标记哪些 Layer 需要更新，但不立即执行</li>
        </ul>

        <h3>1.1 标记机制</h3>

        <p>每个 Layer 内部有多种标记位（dirty flags），用于标记不同类型的更新需求：</p>
        <table>
            <thead>
                <tr>
                    <th>标记类型</th>
                    <th>对应方法</th>
                    <th>作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Layout 标记</strong></td>
                    <td><code class="highlight">setNeedsLayout</code></td>
                    <td>需要重新计算布局</td>
                </tr>
                <tr>
                    <td><strong>Display 标记</strong></td>
                    <td><code class="highlight">setNeedsDisplay</code></td>
                    <td>需要重新生成 bitmap</td>
                </tr>
                <tr>
                    <td><strong>Commit 标记</strong></td>
                    <td>系统自动设置</td>
                    <td>需要提交到 Render Server</td>
                </tr>
            </tbody>
        </table>

        <p>修改 Layer 属性时，系统会根据属性类型自动设置相应的标记位，但更新操作会延迟到后续阶段执行。</p>

        <h3>1.2 系统自动标记的情况</h3>

        <p>系统会自动标记，不需要手动调用 <code class="highlight">setNeedsLayout</code>：</p>
        <table>
            <thead>
                <tr>
                    <th>情况</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>视图被添加到父视图时</td>
                    <td><code class="highlight">addSubview</code> → 系统自动标记</td>
                </tr>
                <tr>
                    <td>父视图的 frame 改变时</td>
                    <td>系统自动标记子视图需要布局</td>
                </tr>
                <tr>
                    <td>Auto Layout 约束更新时</td>
                    <td>系统自动标记</td>
                </tr>
                <tr>
                    <td>设备旋转时</td>
                    <td>系统自动标记</td>
                </tr>
                <tr>
                    <td>视图的 <code class="highlight">bounds</code> 改变时</td>
                    <td>如果 <code class="highlight">autoresizesSubviews</code> 为 true → 系统自动标记</td>
                </tr>
            </tbody>
        </table>

        <h2>2. T1：Layout 阶段（布局计算）</h2>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>RunLoop 进入休眠前，或者手动调用 <code class="highlight">layoutIfNeeded()</code> 时</td>
                </tr>
                <tr>
                    <td><strong>触发时机</strong></td>
                    <td>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li>RunLoop 的 <code class="highlight">kCFRunLoopBeforeWaiting</code> 阶段</li>
                            <li>或者代码中显式调用 <code class="highlight">view.layoutIfNeeded()</code></li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>（见下方表格）</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. 检查哪些视图需要布局</strong></td>
                    <td>检查标记</td>
                    <td>系统只检查被标记为"需要布局"的视图；如果没有调用 <code class="highlight">setNeedsLayout</code>，且系统也没有自动标记，这些视图不会执行 layout</td>
                </tr>
                <tr>
                    <td><strong>2. UIButton 的布局计算</strong></td>
                    <td>布局子视图</td>
                    <td>只有被标记的视图才会执行；<code class="highlight">layoutSubviews()</code> 被调用（如果 UIButton 覆写了这个方法）；UIButton 内部会布局它的子视图：<code class="highlight">UIImageView</code> 的 frame、<code class="highlight">UILabel</code> 的 frame；这些 frame 值会同步到对应的 Layer 的 frame</td>
                </tr>
                <tr>
                    <td><strong>3. Layer 的 frame 同步</strong></td>
                    <td>同步几何属性</td>
                    <td>UIView 的 frame → CALayer 的 frame；CALayer 的 frame → position、bounds、anchorPoint 等属性；此时 Layer 的几何属性才真正确定</td>
                </tr>
            </tbody>
        </table>

        <p><strong>关键点</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>作用</strong></td>
                    <td>只计算位置和大小，不进行绘制</td>
                </tr>
                <tr>
                    <td><strong>contents 状态</strong></td>
                    <td>所有 Layer 的 <code class="highlight">contents</code> 仍然没有生成</td>
                </tr>
                <tr>
                    <td><strong>确定内容</strong></td>
                    <td>这个阶段确定的是"在哪里显示"和"显示多大"</td>
                </tr>
            </tbody>
        </table>

        <h3>2.1 Layout 和 Display 的区别</h3>

        <table>
            <thead>
                <tr>
                    <th>对比项</th>
                    <th>Layout</th>
                    <th>Display</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>作用</strong></td>
                    <td>计算位置和大小</td>
                    <td>生成显示内容</td>
                </tr>
                <tr>
                    <td><strong>计算内容</strong></td>
                    <td>frame、bounds、center 等几何属性</td>
                    <td>生成 bitmap（contents）</td>
                </tr>
                <tr>
                    <td><strong>确定内容</strong></td>
                    <td>"在哪里显示"、"显示多大"</td>
                    <td>"显示什么"</td>
                </tr>
            </tbody>
        </table>

        <h3>2.2 动画中为什么必须用 layoutIfNeeded()？</h3>

        <p>如果想做一个 <code class="highlight">NSLayoutConstraint</code> 的动画，必须先修改 constant，然后在一个 <code class="highlight">UIView.animate</code> 闭包里调用 <code class="highlight">layoutIfNeeded()</code>。如果调用 <code class="highlight">setNeedsLayout()</code>，动画会瞬间完成。</p>

        <table>
            <thead>
                <tr>
                    <th>方法</th>
                    <th>执行方式</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><code class="highlight">setNeedsLayout()</code></td>
                    <td>异步</td>
                    <td>只标记"需要布局"，实际布局会在 RunLoop 下一圈执行</td>
                </tr>
                <tr>
                    <td><code class="highlight">layoutIfNeeded()</code></td>
                    <td>同步</td>
                    <td>立即执行布局计算</td>
                </tr>
            </tbody>
        </table>

        <p><strong>为什么动画中必须用 layoutIfNeeded()</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>原因</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>动画工作原理</strong></td>
                    <td><code class="highlight">UIView.animate</code> 闭包会捕获闭包执行时的视图状态；动画系统会在每一帧更新视图属性，产生动画效果</td>
                </tr>
                <tr>
                    <td><strong>setNeedsLayout() 的问题</strong></td>
                    <td>只是标记，不会立即执行；动画闭包立即结束，动画系统只看到开始和结束状态；等到 RunLoop 下一圈执行布局时，动画闭包已经结束了；结果：看不到动画效果，瞬间完成</td>
                </tr>
                <tr>
                    <td><strong>layoutIfNeeded() 的优势</strong></td>
                    <td>立即执行布局计算；动画系统可以捕获到布局变化的过程；每一帧都会更新布局，产生平滑的动画效果</td>
                </tr>
            </tbody>
        </table>

        <h2>3. T2：Display 阶段（生成 bitmap）</h2>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>Layout 阶段之后，RunLoop 进入休眠前</td>
                </tr>
                <tr>
                    <td><strong>触发时机</strong></td>
                    <td>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li>RunLoop 的 <code class="highlight">kCFRunLoopBeforeWaiting</code> 阶段</li>
                            <li>或者手动调用 <code class="highlight">displayIfNeeded()</code> 时</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>
                        <ol style="margin: 0; padding-left: 20px;">
                            <li><strong>检查哪些 Layer 需要 Display</strong>
                                <ul>
                                    <li>系统检查所有被标记为"需要显示"的 Layer</li>
                                    <li><code class="highlight">setNeedsDisplay</code> 标记的 Layer 会被处理</li>
                                    <li>只有被标记的 Layer 才会执行 Display</li>
                                </ul>
                            </li>
                            <li><strong>CALayer 的 display 方法被调用</strong>
                                <ul>
                                    <li>对于被标记的 Layer，系统会调用 <code class="highlight">display(_:)</code> 方法</li>
                                    <li>这个方法负责生成 bitmap 并存入 <code class="highlight">contents</code></li>
                                </ul>
                            </li>
                        </ol>
                    </td>
                </tr>
            </tbody>
        </table>

        <h3>3.1 CALayer 的 display 方法流程</h3>

        <p><code class="highlight">[CALayer display]</code> 方法被调用时，会根据 delegate 的实现情况，走不同的绘制路径：</p>

        <div class="mermaid">
graph TD
    A[开始: CALayer display 被触发] --> B{delegate 是否响应<br/>displayLayer: ?}
    
    B -- 是 --> C[执行 delegate.displayLayer: layer]
    C --> D{开发者是否手动<br/>赋值 contents?}
    D -- 是 --> E[显示开发者提供的位图]
    D -- 否 --> F[Layer 显示为空白]
    E --> END[结束: 提交至 Render Server]
    F --> END

    B -- 否 --> G{是否满足 CPU 绘图条件?<br/>重写了 drawRect: 或<br/>drawLayer:inContext:}
    
    G -- 是 --> H[1. 创建 Backing Store 位图内存]
    H --> I[2. 执行绘图链条: 调用 drawRect:]
    I --> J[3. 渲染生成位图 CGImage]
    J --> K[4. 赋值: layer.contents = bitmap]
    K --> END
    
    G -- 否 --> L{是否存在已有内容?<br/>如 UIImageView.image<br/>或手动设过 contents}
    
    L -- 是 --> M[直接使用已有 contents 位图]
    M --> END
    
    L -- 否 --> N{是否有样式属性?<br/>backgroundColor / border / corner}
    N -- 是 --> O[GPU 属性渲染路径:<br/>不产生位图内存, 直接指令着色]
    N -- 否 --> P[Layer 完全透明/无内容]
    O --> END
    P --> END

    style B fill:#f9f,stroke:#333,stroke-width:2px
    style G fill:#f96,stroke:#333,stroke-width:2px
    style O fill:#9f9,stroke:#333,stroke-width:2px
    style H fill:#f66,stroke:#333,stroke-width:2px
        </div>

        <p><strong>关键点说明</strong>：</p>

        <ol>
            <li><strong>第一个判断</strong>：<code class="highlight">displayLayer:</code> 方法
                <ul>
                    <li>如果实现了 → 走完全自定义/异步绘制入口（路径 A）</li>
                    <li>系统完全放手，不创建上下文，不调用 drawRect</li>
                    <li>开发者必须手动给 <code class="highlight">layer.contents</code> 赋值</li>
                    <li>如果没实现 → 走系统接管流程（路径 B）</li>
                </ul>
            </li>
            <li><strong>系统接管流程中的关键判定</strong>：是否需要 CPU 绘图？
                <ul>
                    <li>系统会先检查：是否覆写了 <code class="highlight">drawRect:</code> 或实现了 <code class="highlight">drawLayer:inContext:</code></li>
                    <li>如果不需要 CPU 绘图（极速路径）：
                        <ul>
                            <li>不创建 Backing Store，不产生位图内存</li>
                            <li>直接结束，GPU 根据 <code class="highlight">backgroundColor</code> 等属性直接着色</li>
                            <li>这是 90% 普通 UIView 的状态，内存开销极低</li>
                        </ul>
                    </li>
                    <li>如果需要 CPU 绘图（降级路径）：
                        <ul>
                            <li>创建 Backing Store（开辟内存：宽 × 高 × 4 字节）</li>
                            <li>调用绘图链条（<code class="highlight">drawLayer:inContext:</code> 或 <code class="highlight">drawRect:</code>）</li>
                            <li>生成位图，存入 <code class="highlight">layer.contents</code></li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li><strong>drawRect: 的调用条件（唯一路径）</strong>：
                <ul>
                    <li>delegate 没有实现 <code class="highlight">displayLayer:</code>（否则走异步绘制）</li>
                    <li>系统判定需要 CPU 绘图（覆写了 <code class="highlight">drawRect:</code> 或实现了 <code class="highlight">drawLayer:inContext:</code>）</li>
                    <li>delegate 没有实现 <code class="highlight">drawLayer:inContext:</code>（否则走 drawLayer:inContext:）</li>
                    <li>delegate 是 UIView（否则不会调用 drawRect:）</li>
                    <li>UIView 覆写了 <code class="highlight">drawRect:</code> 方法</li>
                    <li>结论：只有同时满足以上所有条件，才会调用 <code class="highlight">drawRect:</code></li>
                </ul>
            </li>
        </ol>

        <h3>3.2 三种不同的 Display 路径</h3>

        <table>
            <thead>
                <tr>
                    <th>路径</th>
                    <th>Layer</th>
                    <th>显示方式</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>路径 A</strong></td>
                    <td>UIButton 自身的 Layer</td>
                    <td>GPU 直接渲染</td>
                    <td>只设置了 <code class="highlight">backgroundColor</code>、<code class="highlight">cornerRadius</code> 等属性，不生成 bitmap，<code class="highlight">contents</code> 保持为 nil</td>
                </tr>
                <tr>
                    <td><strong>路径 B</strong></td>
                    <td>UIImageView 的 Layer</td>
                    <td>图片解码成 bitmap</td>
                    <td>图片文件（PNG/JPEG）需要解码成未压缩的 bitmap，解码后的 bitmap 赋值给 <code class="highlight">layer.contents</code></td>
                </tr>
                <tr>
                    <td><strong>路径 C</strong></td>
                    <td>UILabel 的 Layer</td>
                    <td>文字光栅化成 bitmap</td>
                    <td>Core Text 根据字体、字号、行距等属性进行排版，排版结果光栅化成 bitmap，bitmap 存入 <code class="highlight">layer.contents</code></td>
                </tr>
            </tbody>
        </table>

        <h3>3.3 光栅化是什么？</h3>

        <p><strong>光栅化（Rasterization）</strong>：将矢量图形转换成位图（bitmap）的过程。</p>

        <table>
            <thead>
                <tr>
                    <th>类型</th>
                    <th>定义</th>
                    <th>优点</th>
                    <th>缺点</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>矢量图形</strong></td>
                    <td>用数学公式描述的图形（如文字轮廓、Bezier 曲线）</td>
                    <td>可以无限放大不失真</td>
                    <td>GPU 无法直接渲染，需要先转换成像素</td>
                </tr>
                <tr>
                    <td><strong>位图（bitmap）</strong></td>
                    <td>由像素点组成的图像</td>
                    <td>GPU 可以直接渲染</td>
                    <td>放大后会模糊</td>
                </tr>
            </tbody>
        </table>

        <p><strong>在 UILabel 中的光栅化过程</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>阶段</th>
                    <th>过程</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. Core Text 排版</strong></td>
                    <td>矢量阶段</td>
                    <td>根据字体文件（TTF/OTF）中的轮廓数据，计算出文字的矢量轮廓；轮廓是数学曲线，不是像素</td>
                </tr>
                <tr>
                    <td><strong>2. 光栅化</strong></td>
                    <td>矢量 → 位图</td>
                    <td>将矢量轮廓"填充"成像素点；根据 Label 的 bounds 大小，创建一个像素网格；判断每个像素点是否在文字轮廓内；如果在轮廓内，就填充颜色（通常是黑色）；如果在轮廓边缘，可能做抗锯齿处理（半透明像素）；最终得到一个 bitmap（像素矩阵）</td>
                </tr>
                <tr>
                    <td><strong>3. 存入 contents</strong></td>
                    <td>存储位图</td>
                    <td>光栅化后的 bitmap 存入 <code class="highlight">layer.contents</code>；GPU 可以直接读取这个 bitmap 进行渲染</td>
                </tr>
            </tbody>
        </table>

        <h3>3.4 位图和纹理的关系</h3>

        <table>
            <thead>
                <tr>
                    <th>对比项</th>
                    <th>位图（Bitmap）</th>
                    <th>纹理（Texture）</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>定义</strong></td>
                    <td>由像素点组成的图像数据</td>
                    <td>GPU 内存中的图像数据</td>
                </tr>
                <tr>
                    <td><strong>存储位置</strong></td>
                    <td>CPU 内存（<code class="highlight">layer.contents</code> 存储的就是位图）</td>
                    <td>GPU 显存</td>
                </tr>
                <tr>
                    <td><strong>存储格式</strong></td>
                    <td>二维数组，每个元素是一个像素的颜色值（RGBA）</td>
                    <td>GPU 可以直接读取和渲染的格式</td>
                </tr>
                <tr>
                    <td><strong>大小计算</strong></td>
                    <td>宽 × 高 × 4 字节（每个像素占用 4 字节 RGBA）</td>
                    <td>与位图相同</td>
                </tr>
                <tr>
                    <td><strong>本质</strong></td>
                    <td>图像数据本身</td>
                    <td>位图上传到 GPU 内存后，就变成了纹理</td>
                </tr>
                <tr>
                    <td><strong>转换过程</strong></td>
                    <td colspan="2">CPU 内存（位图） → 上传到 GPU → GPU 内存（纹理） → GPU 渲染</td>
                </tr>
            </tbody>
        </table>

        <p><strong>在 iOS 绘制流程中的位置</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>阶段</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>t2 阶段（Display）</strong></td>
                    <td>生成位图</td>
                    <td>存入 <code class="highlight">layer.contents</code>（CPU 内存）；UILabel：文字光栅化成位图；UIImageView：图片解码成位图</td>
                </tr>
                <tr>
                    <td><strong>t3 阶段（Commit）</strong></td>
                    <td>提交数据</td>
                    <td>位图数据随 Layer 信息一起提交到 Render Server</td>
                </tr>
                <tr>
                    <td><strong>t4 阶段（Render Server）</strong></td>
                    <td>位图上传</td>
                    <td>位图上传到 GPU 内存，变成纹理</td>
                </tr>
                <tr>
                    <td><strong>t5 阶段（GPU 渲染）</strong></td>
                    <td>纹理采样</td>
                    <td>GPU 从纹理中采样像素，进行渲染</td>
                </tr>
            </tbody>
        </table>

        <h3>3.5 异步绘制实现示例</h3>

        <p>如果 delegate 实现了 <code class="highlight">displayLayer:</code> 方法，可以自定义异步绘制逻辑：</p>

        <div class="code-block"><code><span class="comment">// 自定义 CALayer，实现异步绘制</span>
<span class="keyword">@interface</span> <span class="type">AsyncLayer</span> : <span class="type">CALayer</span>
<span class="keyword">@property</span> (atomic, assign) <span class="type">BOOL</span> isDrawing;  <span class="comment">// 绘制状态标记</span>
<span class="keyword">@end</span>

<span class="keyword">@implementation</span> <span class="type">AsyncLayer</span>

- (<span class="keyword">void</span>)setNeedsDisplay {
    <span class="comment">// 收到新的绘制请求时，取消正在绘制的线程</span>
    <span class="keyword">self</span>.isDrawing = <span class="keyword">NO</span>;
    [<span class="keyword">super</span> setNeedsDisplay];
}

- (<span class="keyword">void</span>)display {
    <span class="comment">// 判断 delegate 是否实现了 displayLayer: 方法</span>
    <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(displayLayer:)]) {
        <span class="comment">// ✅ 走异步绘制入口</span>
        [<span class="keyword">self</span> asyncDraw];
    } <span class="keyword">else</span> {
        <span class="comment">// ❌ 走系统绘制流程</span>
        [<span class="keyword">super</span> display];
    }
}

- (<span class="keyword">void</span>)asyncDraw {
    <span class="keyword">self</span>.isDrawing = <span class="keyword">YES</span>;
    
    <span class="comment">// 在后台线程进行绘制</span>
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^{
        
        <span class="comment">// 检查是否被取消</span>
        <span class="keyword">if</span> (!<span class="keyword">self</span>.isDrawing) <span class="keyword">return</span>;
        
        <span class="comment">// 1. 创建绘制上下文（后台线程）</span>
        <span class="type">CGSize</span> size = <span class="keyword">self</span>.bounds.size;
        <span class="type">CGFloat</span> scale = [<span class="type">UIScreen</span> mainScreen].scale;
        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="keyword">self</span>.opaque, scale);
        <span class="type">CGContextRef</span> context = <span class="type">UIGraphicsGetCurrentContext</span>();
        
        <span class="comment">// 2. 设置背景色（如果需要）</span>
        <span class="keyword">if</span> (<span class="keyword">self</span>.opaque && <span class="keyword">self</span>.backgroundColor) {
            <span class="type">CGContextSetFillColorWithColor</span>(context, <span class="keyword">self</span>.backgroundColor);
            <span class="type">CGContextFillRect</span>(context, <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width * scale, size.height * scale));
        }
        
        <span class="comment">// 3. 调用 delegate 的绘制方法（后台线程）</span>
        <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(drawLayer:inContext:)]) {
            [<span class="keyword">self</span>.delegate drawLayer:<span class="keyword">self</span> inContext:context];
        }
        
        <span class="comment">// 4. 检查是否被取消</span>
        <span class="keyword">if</span> (!<span class="keyword">self</span>.isDrawing) {
            <span class="type">UIGraphicsEndImageContext</span>();
            <span class="keyword">return</span>;
        }
        
        <span class="comment">// 5. 从上下文生成图片</span>
        <span class="type">UIImage</span> *image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>();
        <span class="type">UIGraphicsEndImageContext</span>();
        
        <span class="comment">// 6. 在主线程设置 contents</span>
        dispatch_async(dispatch_get_main_queue(), ^{
            <span class="keyword">if</span> (<span class="keyword">self</span>.isDrawing) {
                <span class="keyword">self</span>.contents = (__bridge id)(image.CGImage);
            }
        });
    });
}

<span class="keyword">@end</span></code></div>

        <h3>3.6 系统绘制 vs 异步绘制</h3>

        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>系统绘制（drawRect）</th>
                    <th>异步绘制（displayLayer）</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>触发条件</strong></td>
                    <td>delegate 没有实现 <code class="highlight">displayLayer:</code></td>
                    <td>delegate 实现了 <code class="highlight">displayLayer:</code></td>
                </tr>
                <tr>
                    <td><strong>执行线程</strong></td>
                    <td>主线程</td>
                    <td>可以后台线程</td>
                </tr>
                <tr>
                    <td><strong>内存消耗</strong></td>
                    <td>大（backing store）</td>
                    <td>大（backing store）</td>
                </tr>
                <tr>
                    <td><strong>使用场景</strong></td>
                    <td>默认路径，简单绘制</td>
                    <td>复杂绘制，需要性能优化</td>
                </tr>
                <tr>
                    <td><strong>是否阻塞主线程</strong></td>
                    <td>是</td>
                    <td>否（如果实现得当）</td>
                </tr>
            </tbody>
        </table>

        <p><strong>关键点</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>要点</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>路径判断</strong></td>
                    <td><code class="highlight">display</code> 方法中判断 delegate 是否实现了 <code class="highlight">displayLayer:</code>，决定走哪个路径</td>
                </tr>
                <tr>
                    <td><strong>异步绘制</strong></td>
                    <td>异步绘制在后台线程创建 context 并绘制</td>
                </tr>
                <tr>
                    <td><strong>主线程设置</strong></td>
                    <td>绘制完成后，必须在主线程设置 <code class="highlight">layer.contents</code></td>
                </tr>
                <tr>
                    <td><strong>取消逻辑</strong></td>
                    <td>需要处理取消逻辑，避免重复绘制</td>
                </tr>
            </tbody>
        </table>

        <h2>4. T3：CATransaction Commit 阶段（提交到 Render Server）</h2>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>Display 阶段之后，RunLoop 进入休眠前</td>
                </tr>
                <tr>
                    <td><strong>触发时机</strong></td>
                    <td>
                        <ul style="margin: 0; padding-left: 20px;">
                            <li>RunLoop 的 <code class="highlight">kCFRunLoopBeforeWaiting</code> 阶段</li>
                            <li>或者手动调用 <code class="highlight">CATransaction.commit()</code> 时</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>（见下方表格）</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. CATransaction 的作用</strong></td>
                    <td>事务机制</td>
                    <td>CATransaction 是 Core Animation 的事务机制；用于批量处理多个 Layer 的更新，统一提交到 Render Server；每个 RunLoop 周期会自动创建一个隐式事务</td>
                </tr>
                <tr>
                    <td><strong>2. 收集需要提交的 Layer</strong></td>
                    <td>收集标记</td>
                    <td>系统收集所有被标记为"需要提交"的 Layer；包括所有在 t0、t1、t2 阶段被修改的 Layer</td>
                </tr>
                <tr>
                    <td><strong>3. 三种 Layer 树</strong></td>
                    <td>构建树结构</td>
                    <td>Model Tree、Presentation Tree、Render Tree（见下方表格）</td>
                </tr>
                <tr>
                    <td><strong>4. 构建 Render Tree</strong></td>
                    <td>构建渲染树</td>
                    <td>根据 Model Tree（应用层的 Layer 树）构建 Render Tree；Render Tree 包含所有需要渲染的信息：几何属性、视觉属性、层级关系</td>
                </tr>
                <tr>
                    <td><strong>5. 序列化 Layer 数据</strong></td>
                    <td>序列化并发送</td>
                    <td>将 Render Tree 序列化成二进制数据；通过 IPC（进程间通信）发送到 Render Server（backboardd 进程）</td>
                </tr>
            </tbody>
        </table>

        <h3>4.1 三种 Layer 树</h3>

        <p>iOS 中有三种 Layer 树，它们在不同阶段发挥作用：</p>

        <table>
            <thead>
                <tr>
                    <th>树类型</th>
                    <th>存在时间</th>
                    <th>位置</th>
                    <th>作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Model Tree（模型树）</strong></td>
                    <td>t0 阶段开始，一直存在</td>
                    <td>应用进程内存中</td>
                    <td>存储 Layer 的最终状态（你设置的属性值）</td>
                </tr>
                <tr>
                    <td><strong>Presentation Tree（呈现树）</strong></td>
                    <td>动画进行时</td>
                    <td>应用进程内存中</td>
                    <td>存储动画的中间值，供应用层查询（如 <code class="highlight">layer.presentation()</code>）</td>
                </tr>
                <tr>
                    <td><strong>Render Tree（渲染树）</strong></td>
                    <td>t3 阶段构建，提交到 Render Server</td>
                    <td>Render Server 进程内存中</td>
                    <td>存储需要渲染的所有信息，用于实际渲染</td>
                </tr>
            </tbody>
        </table>

        <p><strong>三种树的关系</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>时间线</th>
                    <th>操作</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>t0-t2</strong></td>
                    <td>Model Tree（应用层设置属性）</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>根据 Model Tree 构建 Render Tree</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>Render Tree 序列化，发送到 Render Server</td>
                </tr>
                <tr>
                    <td><strong>t4+</strong></td>
                    <td>Render Server 使用 Render Tree 进行渲染</td>
                </tr>
                <tr>
                    <td><strong>动画时</strong></td>
                    <td>Model Tree（最终值） → Presentation Tree（中间值） → Render Tree（渲染）</td>
                </tr>
            </tbody>
        </table>

        <p><strong>这个阶段发生了什么（续）</strong>：</p>

        <ol>
            <li><strong>三种 Layer 树</strong>（见上方表格）</li>
        </ol>

        <p><strong>关键点</strong>：</p>
        <ul>
            <li>Commit 阶段不进行实际渲染，只是提交数据</li>
            <li>Render Server 是独立进程，与应用进程分离</li>
            <li>所有 Layer 的更新会批量提交，提高效率</li>
        </ul>

        <h3>4.2 动画和 RunLoop 的关系</h3>

        <p><strong>关键误解</strong>：动画的每一帧渲染不是由 RunLoop 驱动的！</p>

        <table>
            <thead>
                <tr>
                    <th>对比项</th>
                    <th>RunLoop</th>
                    <th>Render Server</th>
                    <th>VSync</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>提交时机</strong></td>
                    <td>休眠前会提交一次渲染（一次性提交，不是每帧都提交）</td>
                    <td>收到提交后持续渲染</td>
                    <td>每秒 60 次信号</td>
                </tr>
                <tr>
                    <td><strong>提交内容</strong></td>
                    <td>动画的开始状态和结束状态，以及动画参数（时长、曲线等）</td>
                    <td>根据动画参数计算每一帧的中间值</td>
                    <td>触发渲染信号</td>
                </tr>
                <tr>
                    <td><strong>驱动方式</strong></td>
                    <td>RunLoop 驱动</td>
                    <td>VSync 驱动</td>
                    <td>硬件驱动</td>
                </tr>
                <tr>
                    <td><strong>频率</strong></td>
                    <td>一次提交</td>
                    <td>60 次/秒</td>
                    <td>60 次/秒</td>
                </tr>
            </tbody>
        </table>

        <p><strong>动画时的流程</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>阶段</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>t0</strong></td>
                    <td>代码执行，设置动画</td>
                    <td>修改属性值</td>
                </tr>
                <tr>
                    <td><strong>t1-t2</strong></td>
                    <td>Layout 和 Display</td>
                    <td>如果需要</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>提交动画到 Render Server</td>
                    <td>提交起始值、结束值、动画参数，不是提交每一帧的值</td>
                </tr>
                <tr>
                    <td><strong>动画开始后（Render Server 端）</strong></td>
                    <td>VSync 信号触发</td>
                    <td>VSync 信号 1 → Render Server 计算第 1 帧的中间值 → GPU 渲染<br>VSync 信号 2 → Render Server 计算第 2 帧的中间值 → GPU 渲染<br>...</td>
                </tr>
            </tbody>
        </table>

        <h3>4.3 Presentation Tree 的真正作用</h3>

        <p><strong>核心结论</strong>：Render Server 才是计算中心</p>

        <p>动画开始后，App 进程只提交一次，剩下的活儿全是 Render Server 的：</p>
        <ol>
            <li><strong>App 进程（t3 阶段）</strong>：把动画的"剧本"（起始值、终点值、时长、插值曲线函数）打包成一个 <code class="highlight">CATransaction</code> 发送给 Render Server，只提交一次</li>
            <li><strong>Render Server（动画过程中）</strong>：它是独立进程，内部有一个由 VSync 驱动的计时器，每一帧根据"剧本"公式，自己计算出当前时刻位图应该在哪个坐标，直接命令 GPU 绘制，不依赖 App 进程的每帧计算</li>
            <li><strong>App 进程（动画过程中）</strong>：不需要参与每一帧的计算，即使主线程被卡死，动画依然会流畅地运行</li>
        </ol>

        <p><strong>Presentation Tree 的本质</strong>：它是一个"镜像查询接口"</p>
        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>计算时机</strong></td>
                    <td>它不是被主动"计算"出来提交的，而是当你访问 <code class="highlight">layer.presentation()</code> 时，UIKit 才去向 Render Server 询问（或者根据时间戳本地推算）</td>
                </tr>
                <tr>
                    <td><strong>主要用途</strong></td>
                    <td>主要用于处理交互，比如一个移动的按钮，你点击时，需要知道它此刻在屏幕的什么位置</td>
                </tr>
                <tr>
                    <td><strong>与 Render Server 的关系</strong></td>
                    <td>是 Render Server 中当前帧状态在 App 进程中的投影</td>
                </tr>
            </tbody>
        </table>

        <h3>4.4 两种动画的本质区别</h3>

        <table>
            <thead>
                <tr>
                    <th>对比项</th>
                    <th>Core Animation 动画（显式或隐式动画）</th>
                    <th>基于 CADisplayLink 的手动动画</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>提交次数</strong></td>
                    <td>1 次（提交剧本）</td>
                    <td>每秒 60/120 次</td>
                </tr>
                <tr>
                    <td><strong>执行者</strong></td>
                    <td>Render Server</td>
                    <td>App 进程（主线程）</td>
                </tr>
                <tr>
                    <td><strong>依赖关系</strong></td>
                    <td>不依赖 App 进程的每帧计算</td>
                    <td>App 进程每帧都计算和提交</td>
                </tr>
                <tr>
                    <td><strong>性能</strong></td>
                    <td>高效，即使主线程卡顿，动画依然流畅</td>
                    <td>非常消耗 CPU 性能</td>
                </tr>
                <tr>
                    <td><strong>例子</strong></td>
                    <td><code class="highlight">UIView.animate</code>、<code class="highlight">CABasicAnimation</code> 等</td>
                    <td>手动写了 <code class="highlight">CADisplayLink</code>，并在回调里每帧修改 <code class="highlight">view.center</code></td>
                </tr>
            </tbody>
        </table>

        <h2>5. T4：Render Server 处理阶段（准备渲染）</h2>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>T3 阶段提交数据后，Render Server 接收并处理</td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>（见下方表格）</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. 接收 Render Tree 数据</strong></td>
                    <td>通过 IPC 接收</td>
                    <td>Render Server 通过 IPC 接收序列化的 Render Tree 数据；反序列化，重建 Render Tree 结构</td>
                </tr>
                <tr>
                    <td><strong>2. 处理位图数据</strong></td>
                    <td>位图上传到 GPU</td>
                    <td>对于有 <code class="highlight">contents</code> 的 Layer（如 UIImageView、UILabel）；位图 → 纹理：位图从 CPU 内存复制到 GPU 显存，变成纹理；GPU 可以直接读取纹理进行渲染</td>
                </tr>
                <tr>
                    <td><strong>3. 准备渲染数据</strong></td>
                    <td>构建渲染命令</td>
                    <td>根据 Render Tree 构建渲染命令；包括：几何信息、视觉属性、层级关系、渲染顺序和混合模式</td>
                </tr>
                <tr>
                    <td><strong>4. 等待 VSync 信号</strong></td>
                    <td>等待硬件信号</td>
                    <td>Render Server 准备好渲染数据后，等待 VSync 信号；VSync 信号由显示硬件发出，每秒 60 次（或 120 次，取决于设备）；VSync 信号表示"屏幕准备好显示新的一帧"</td>
                </tr>
            </tbody>
        </table>

        <p><strong>关键点</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>要点</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>独立进程</strong></td>
                    <td>Render Server 是独立进程，不受应用进程影响</td>
                </tr>
                <tr>
                    <td><strong>异步操作</strong></td>
                    <td>位图上传到 GPU 是异步操作，不阻塞应用进程</td>
                </tr>
                <tr>
                    <td><strong>等待信号</strong></td>
                    <td>Render Server 准备好数据后，等待 VSync 信号才开始渲染</td>
                </tr>
            </tbody>
        </table>

        <h2>6. T5：GPU 渲染阶段（渲染到屏幕）</h2>

        <table>
            <thead>
                <tr>
                    <th>项目</th>
                    <th>内容</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>时间点</strong></td>
                    <td>VSync 信号触发后，GPU 开始渲染</td>
                </tr>
                <tr>
                    <td><strong>这个阶段发生了什么</strong></td>
                    <td>（见下方内容）</td>
                </tr>
            </tbody>
        </table>

        <h3>6.1 GPU 渲染管线（Rendering Pipeline）</h3>

        <p>GPU 按照固定的渲染管线处理每一帧：</p>

        <table>
            <thead>
                <tr>
                    <th>阶段</th>
                    <th>名称</th>
                    <th>作用</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1</strong></td>
                    <td>顶点着色（Vertex Shading）</td>
                    <td>处理 Layer 的几何信息（position、bounds、transform）；将 Layer 的顶点坐标转换到屏幕坐标系；应用变换矩阵（transform）</td>
                </tr>
                <tr>
                    <td><strong>2</strong></td>
                    <td>图元装配（Primitive Assembly）</td>
                    <td>将顶点组装成图元（三角形、四边形等）；确定哪些图元在屏幕可见区域内</td>
                </tr>
                <tr>
                    <td><strong>3</strong></td>
                    <td>光栅化（Rasterization）</td>
                    <td>将图元转换成像素片段（fragments）；确定每个像素的颜色值</td>
                </tr>
                <tr>
                    <td><strong>4</strong></td>
                    <td>片段着色（Fragment Shading）</td>
                    <td>对每个像素片段进行着色；如果有纹理（texture），从纹理中采样颜色；应用视觉属性（backgroundColor、opacity 等）；处理混合模式（blend mode）</td>
                </tr>
                <tr>
                    <td><strong>5</strong></td>
                    <td>片段处理（Fragment Processing）</td>
                    <td>深度测试（z-order）；模板测试；混合（blending）</td>
                </tr>
                <tr>
                    <td><strong>6</strong></td>
                    <td>写入 FrameBuffer</td>
                    <td>将渲染结果写入 FrameBuffer（帧缓冲区）；FrameBuffer 是 GPU 内存中的一块区域，存储最终要显示的图像</td>
                </tr>
            </tbody>
        </table>

        <h3>6.2 双缓冲机制（Double Buffering）</h3>

        <table>
            <thead>
                <tr>
                    <th>Buffer</th>
                    <th>作用</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Front Buffer</strong></td>
                    <td>当前显示</td>
                    <td>当前显示在屏幕上的帧</td>
                </tr>
                <tr>
                    <td><strong>Back Buffer</strong></td>
                    <td>正在渲染</td>
                    <td>正在渲染的帧</td>
                </tr>
            </tbody>
        </table>

        <p><strong>工作流程</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1</strong></td>
                    <td>GPU 在 Back Buffer 中渲染新帧</td>
                    <td>渲染新的一帧内容</td>
                </tr>
                <tr>
                    <td><strong>2</strong></td>
                    <td>VSync 信号到来时，交换 Buffer</td>
                    <td>Front Buffer 和 Back Buffer 交换</td>
                </tr>
                <tr>
                    <td><strong>3</strong></td>
                    <td>显示 Front Buffer 的内容</td>
                    <td>保证屏幕显示的是完整的帧，不会出现撕裂（tearing）</td>
                </tr>
            </tbody>
        </table>

        <h3>6.3 VSync 信号的作用</h3>

        <table>
            <thead>
                <tr>
                    <th>作用</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>同步渲染和显示</strong></td>
                    <td>确保 GPU 渲染完成后再显示</td>
                </tr>
                <tr>
                    <td><strong>防止撕裂</strong></td>
                    <td>在屏幕刷新间隙交换 Buffer</td>
                </tr>
                <tr>
                    <td><strong>控制帧率</strong></td>
                    <td>限制渲染频率，避免过度渲染</td>
                </tr>
            </tbody>
        </table>

        <h3>6.4 显示到屏幕</h3>

        <table>
            <thead>
                <tr>
                    <th>步骤</th>
                    <th>操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1</strong></td>
                    <td>FrameBuffer 数据输出</td>
                    <td>FrameBuffer 中的数据通过显示控制器（Display Controller）输出到屏幕</td>
                </tr>
                <tr>
                    <td><strong>2</strong></td>
                    <td>屏幕扫描显示</td>
                    <td>屏幕硬件按照刷新率（60Hz 或 120Hz）逐行扫描显示</td>
                </tr>
                <tr>
                    <td><strong>3</strong></td>
                    <td>用户看到结果</td>
                    <td>最终用户看到渲染结果</td>
                </tr>
            </tbody>
        </table>

        <p><strong>关键点</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>要点</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>并行处理</strong></td>
                    <td>GPU 渲染是并行处理的，非常高效</td>
                </tr>
                <tr>
                    <td><strong>同步机制</strong></td>
                    <td>VSync 信号保证渲染和显示同步</td>
                </tr>
                <tr>
                    <td><strong>防止撕裂</strong></td>
                    <td>双缓冲机制防止画面撕裂</td>
                </tr>
                <tr>
                    <td><strong>掉帧条件</strong></td>
                    <td>如果 GPU 渲染时间超过 16.67ms（60 FPS），会出现掉帧</td>
                </tr>
            </tbody>
        </table>

        <h3>6.5 性能考虑</h3>

        <p><strong>GPU 渲染瓶颈</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>瓶颈类型</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>纹理大小</strong></td>
                    <td>大纹理占用显存</td>
                </tr>
                <tr>
                    <td><strong>视图混合</strong></td>
                    <td>多个 Layer 混合需要更多计算</td>
                </tr>
                <tr>
                    <td><strong>离屏渲染</strong></td>
                    <td>off-screen rendering，需要额外的渲染 pass</td>
                </tr>
            </tbody>
        </table>

        <p><strong>掉帧的原因</strong>：</p>
        <table>
            <thead>
                <tr>
                    <th>原因</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>CPU 处理时间过长</strong></td>
                    <td>Layout、Display 阶段耗时过长</td>
                </tr>
                <tr>
                    <td><strong>GPU 渲染时间过长</strong></td>
                    <td>复杂图形、大量混合</td>
                </tr>
                <tr>
                    <td><strong>位图上传时间过长</strong></td>
                    <td>大图片上传到 GPU 耗时</td>
                </tr>
            </tbody>
        </table>

        <h2>7. 总结</h2>

        <p>整个流程可以总结为：</p>

        <table>
            <thead>
                <tr>
                    <th>阶段</th>
                    <th>名称</th>
                    <th>主要操作</th>
                    <th>关键点</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>t0</strong></td>
                    <td>代码执行阶段</td>
                    <td>修改属性值，标记需要更新</td>
                    <td>只修改属性值，不进行实际绘制；系统标记哪些 Layer 需要更新</td>
                </tr>
                <tr>
                    <td><strong>t1</strong></td>
                    <td>Layout 阶段</td>
                    <td>计算位置和大小</td>
                    <td>只计算位置和大小，不进行绘制；确定"在哪里显示"和"显示多大"</td>
                </tr>
                <tr>
                    <td><strong>t2</strong></td>
                    <td>Display 阶段</td>
                    <td>生成 bitmap</td>
                    <td>生成 bitmap，存入 <code class="highlight">layer.contents</code>；图片解码、文字光栅化</td>
                </tr>
                <tr>
                    <td><strong>t3</strong></td>
                    <td>Commit 阶段</td>
                    <td>提交到 Render Server</td>
                    <td>构建 Render Tree，序列化数据，通过 IPC 发送到 Render Server</td>
                </tr>
                <tr>
                    <td><strong>t4</strong></td>
                    <td>Render Server 处理阶段</td>
                    <td>位图上传到 GPU</td>
                    <td>位图 → 纹理：位图从 CPU 内存复制到 GPU 显存；准备渲染数据</td>
                </tr>
                <tr>
                    <td><strong>t5</strong></td>
                    <td>GPU 渲染阶段</td>
                    <td>渲染到屏幕</td>
                    <td>GPU 渲染管线处理；双缓冲机制；VSync 信号同步；最终显示到屏幕</td>
                </tr>
            </tbody>
        </table>

        <p>每个阶段都有其特定的职责，共同完成了从代码到屏幕显示的完整流程。</p>
    </div>
</body>
</html>
