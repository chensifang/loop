# 绘制知识草稿

用于整理和讨论 iOS 绘制相关知识，确认清楚后再整理成 HTML 笔记。

---

## 待讨论的问题

- [ ] CALayer 的显示基础（contents、backing store、两种显示方式）
- [ ] 三种 Layer 树
- [ ] setNeedsDisplay 的调用流程
- [ ] CALayer 的 display 方法
- [ ] drawRect 的调用流程
- [ ] CATransaction 的四个阶段
- [ ] Render Server
- [ ] GPU 渲染管线
- [ ] VSync 和显示原理
- [ ] CPU/GPU 层面的性能优化

---

## 一、以 UIButton（有文字 + 有图片）串整个绘制流程

### UIButton 的 Layer 结构

UIButton 内部有多个子视图，对应多个 CALayer：

- UIButton 自身 → 1 个 CALayer（负责背景色、圆角等）
- UIImageView（内部图片视图）→ 1 个 CALayer
- UILabel（内部文字视图）→ 1 个 CALayer

一个按钮背后是 3 个 CALayer 在工作。

---

### 三个 Layer 各自的显示方式（待确认）

#### 1. UIButton 自身的 Layer（背景）

- 只设置了 backgroundColor、cornerRadius 等属性
- 没有 contents，GPU 直接根据这些属性渲染几何图形
- 不需要 bitmap

> ⚠️ 存疑：UIButton 自身的 Layer 真的没有 contents 吗？还是某个时机也会生成 bitmap？

#### 2. UIImageView 的 Layer（图片）

- 图片文件（PNG/JPEG）从磁盘读取后需要解码成 bitmap
- 解码后的 bitmap 赋值给 layer.contents
- GPU 从 contents 读取 bitmap 进行纹理渲染

#### 3. UILabel 的 Layer（文字）

- 文字通过 Core Text 排版
- 排版结果光栅化成 bitmap
- bitmap 存入 layer.contents
- GPU 从 contents 读取 bitmap 进行纹理渲染

---

---

## 二、从代码到屏幕显示的完整时间线

### t0：代码执行阶段（主线程）

**时间点**：代码执行时，在主线程同步执行

**示例代码**：
```swift
let button = UIButton(type: .system)
button.frame = CGRect(x: 100, y: 100, width: 200, height: 50)
button.setTitle("点击", for: .normal)
button.setImage(UIImage(named: "icon"), for: .normal)
button.backgroundColor = UIColor.blue
button.layer.cornerRadius = 8
view.addSubview(button)
```

**这个阶段发生了什么**：

1. **创建 UIButton 对象**
   - 在堆上分配内存
   - 创建 UIButton 的 CALayer（此时 contents 为 nil）
   - 创建内部的 UIImageView 和 UILabel（各自也有 CALayer）

2. **设置 frame**
   - `button.frame = ...` → 实际设置的是 `layer.frame`
   - Layer 的 frame 属性被修改
   - **此时还没有布局计算**，只是属性值被设置

3. **设置文字**
   - `button.setTitle(...)` → 内部 UILabel 的 text 属性被设置
   - UILabel 的 Layer 标记需要更新（内部调用类似 setNeedsDisplay）
   - **但此时还没有生成 bitmap**

4. **设置图片**
   - `button.setImage(...)` → 内部 UIImageView 的 image 属性被设置
   - UIImageView 的 Layer 标记需要更新
   - **图片文件还在内存中，还没有解码成 bitmap**

5. **设置背景色和圆角**
   - `backgroundColor`、`cornerRadius` → Layer 的属性被设置
   - UIButton 自身的 Layer 标记需要更新

6. **添加到视图层级**
   - `view.addSubview(button)` → button 被添加到视图树
   - button 的 Layer 被添加到 Layer 树（Model Tree）
   - **此时 Layer 树已经建立，但还没有渲染**

**关键点**：
- 这个阶段**只修改属性值**，不进行实际绘制
- 所有 Layer 的 `contents` 都还是 nil（或之前的值）
- 系统只是**标记**哪些 Layer 需要更新，但**不立即执行**

**标记机制**：
- 每个 Layer 内部有多种标记位（dirty flags），用于标记不同类型的更新需求：
  - **Layout 标记**：需要重新计算布局（对应 `setNeedsLayout`）
  - **Display 标记**：需要重新生成 bitmap（对应 `setNeedsDisplay`）
  - **Commit 标记**：需要提交到 Render Server
- 修改 Layer 属性时，系统会根据属性类型自动设置相应的标记位
- 但更新操作会延迟到后续阶段执行

**Layer 的 dirty flag 和 setNeedsLayout 的区别**：
- `setNeedsLayout`：UIView 的方法，专门标记"需要布局"
- Layer 的 dirty flag：CALayer 内部的标记机制，包括 layout、display、commit 等多种标记
- `setNeedsLayout` 实际上会设置 Layer 的 layout dirty flag
- 但 Layer 还有其他 dirty flags，比如 display dirty flag（由 `setNeedsDisplay` 设置）

---

### t1：Layout 阶段（布局计算）

**时间点**：RunLoop 进入休眠前，或者手动调用 `layoutIfNeeded()` 时

**触发时机**：
- RunLoop 的 `kCFRunLoopBeforeWaiting` 阶段
- 或者代码中显式调用 `view.layoutIfNeeded()`

**这个阶段发生了什么**：

---

#### ❓ 问题 1：如果没有调用 setNeedsLayout，视图就不会更新吗？

**回答**：
- **不是的**！系统会自动标记，不需要手动调用 `setNeedsLayout`
- **系统会自动标记的情况**：
  - 视图被添加到父视图时（`addSubview`）→ **系统自动标记**
  - 父视图的 frame 改变时 → **系统自动标记**子视图需要布局
  - Auto Layout 约束更新时 → **系统自动标记**
  - 设备旋转时 → **系统自动标记**
  - 视图的 `bounds` 改变时（如果 `autoresizesSubviews` 为 true）→ **系统自动标记**

**关键理解**：
- **系统会自动标记**：不需要手动调用 `setNeedsLayout`，系统在特定情况下会自动标记视图需要布局
- **手动标记也可以**：也可以手动调用 `setNeedsLayout` 来标记
- **只有被标记的视图才会执行 layout**：RunLoop 休眠前，系统只处理被标记的视图

**在我们的 UIButton 例子中**：
- `view.addSubview(button)` → **系统自动标记** button 需要布局
- 不需要手动调用 `setNeedsLayout`
- RunLoop 休眠前会自动执行 layout

---

#### ❓ 问题 2：Layer 的 dirty flag 和 setNeedsLayout 是一回事吗？

**回答**：
- **不是一回事**！
- **Layer 的 dirty flag**：CALayer 内部的标记机制，包括多种类型：
  - Layout 标记（需要布局）
  - Display 标记（需要生成 bitmap）
  - Commit 标记（需要提交到 Render Server）
- **`setNeedsLayout`**：UIView 的方法，只设置 Layer 的 Layout 标记
- **关系**：
  - `setNeedsLayout` → 设置 Layer 的 Layout dirty flag
  - `setNeedsDisplay` → 设置 Layer 的 Display dirty flag
  - Layer 的 dirty flag 是更广泛的概念，包含多种标记类型

---

#### ❓ 问题 3：一般什么情况需要手动调用 setNeedsLayout？

**回答**：
**更正**：之前说的例子是错误的！修改 `label.text` 时，系统会自动标记，不需要手动调用 `setNeedsLayout`。

**实际情况**：
- **99% 的情况不需要手动调用**：系统会自动检测并标记
  - 修改 `label.text` → 系统自动标记
  - 修改 `imageView.image` → 系统自动标记
  - 修改 `frame`、`bounds` → 系统自动标记
  - 异步回调中修改属性 → 系统也会自动标记

**真正需要手动调用的场景（非常少见）**：
1. **自定义布局逻辑，需要强制触发**
   - 覆写了 `layoutSubviews`，但触发条件不是系统自动检测的
   - 例如：自定义布局算法，需要手动触发重新计算
   ```swift
   class CustomView: UIView {
       var customLayoutFlag = false
       
       func triggerCustomLayout() {
           customLayoutFlag = true
           self.setNeedsLayout() // 强制触发 layoutSubviews
       }
       
       override func layoutSubviews() {
           super.layoutSubviews()
           if customLayoutFlag {
               // 执行自定义布局逻辑
           }
       }
   }
   ```

2. **性能优化场景（可选）**
   - 批量修改多个视图属性时，可以先修改所有属性，最后统一调用一次 `setNeedsLayout`
   - 但这通常不是必须的，因为系统会合并多次标记

**总结**：
- **几乎不需要手动调用**：系统会自动标记所有标准属性变化
- **手动调用的场景**：自定义布局逻辑，需要强制触发 `layoutSubviews`

---

#### ❓ 问题 4：动画中为什么必须用 layoutIfNeeded() 而不能用 setNeedsLayout()？

**问题描述**：
如果想做一个 NSLayoutConstraint 的动画，必须先修改 constant，然后在一个 UIView.animate 闭包里调用 `layoutIfNeeded()`。如果调用 `setNeedsLayout()`，动画会瞬间完成，因为它是异步的，等 RunLoop 下一圈再更新时，动画闭包已经结束了。

**回答**：

**关键区别**：
- **`setNeedsLayout()`**：异步的，只标记"需要布局"，实际布局会在 RunLoop 下一圈执行
- **`layoutIfNeeded()`**：同步的，立即执行布局计算

**为什么动画中必须用 `layoutIfNeeded()`**：

1. **动画的工作原理**：
   - `UIView.animate` 闭包会捕获闭包执行时的视图状态
   - 动画系统会在每一帧更新视图属性，产生动画效果
   - 如果布局更新是异步的，动画系统无法捕获到中间状态

2. **`setNeedsLayout()` 的问题**：
   ```swift
   constraint.constant = 100
   UIView.animate(withDuration: 0.3) {
       self.view.setNeedsLayout() // ❌ 错误！
   }
   ```
   - `setNeedsLayout()` 只是标记，不会立即执行
   - 动画闭包立即结束，动画系统只看到开始和结束状态
   - 等到 RunLoop 下一圈执行布局时，动画闭包已经结束了
   - 结果：看不到动画效果，瞬间完成

3. **`layoutIfNeeded()` 的正确用法**：
   ```swift
   constraint.constant = 100
   UIView.animate(withDuration: 0.3) {
       self.view.layoutIfNeeded() // ✅ 正确！
   }
   ```
   - `layoutIfNeeded()` 立即执行布局计算
   - 动画系统可以捕获到布局变化的过程
   - 每一帧都会更新布局，产生平滑的动画效果

**总结**：
- **动画中必须用 `layoutIfNeeded()`**：同步执行，让动画系统能捕获每一帧的变化
- **`setNeedsLayout()` 不适合动画**：异步执行，动画闭包结束时布局还没更新

---

**这个阶段的具体流程**：

3. **UIButton 的布局计算**（只有被标记的视图才会执行）
   - `layoutSubviews()` 被调用（如果 UIButton 覆写了这个方法）
   - UIButton 内部会布局它的子视图：
     - UIImageView 的 frame
     - UILabel 的 frame
   - 这些 frame 值会同步到对应的 Layer 的 frame

4. **Layer 的 frame 同步**
   - UIView 的 frame → CALayer 的 frame
   - CALayer 的 frame → position、bounds、anchorPoint 等属性
   - **此时 Layer 的几何属性才真正确定**

5. **内部子视图的布局**
   - UIImageView 的 Layer frame 被确定
   - UILabel 的 Layer frame 被确定
   - UIButton 自身的 Layer frame 被确定

**关键理解**：
- **Layout 不是必须的**：如果视图没有子视图，或者子视图位置是固定的，可能不需要 layout
- **直接修改 frame**：`button.frame = ...` 会直接修改 Layer 的 frame，不需要 layout
- **Layout 的作用**：主要是计算子视图的位置（`layoutSubviews`）
- **在我们的例子中**：`addSubview(button)` 会自动标记 button 需要 layout，所以会执行

**关键点**：
- Layout 阶段**只计算位置和大小**，不进行绘制
- 所有 Layer 的 `contents` 仍然没有生成
- 这个阶段确定的是"在哪里显示"和"显示多大"

**Layout 和 Display 的区别**：
- Layout：计算 frame、bounds、center 等几何属性
- Display：生成 bitmap（contents），准备显示内容

**标记机制**：
- `setNeedsLayout` → 标记需要布局（手动标记）
- `layoutIfNeeded` → 立即执行布局（同步）
- RunLoop 结束前 → 自动执行所有标记的布局（异步）

**系统自动触发布局的情况**（不需要显式调用 `setNeedsLayout`）：
- 视图被添加到父视图时（`addSubview`）
- 视图的 frame 被修改时（某些情况下）
- 父视图的 frame 改变时（子视图需要重新布局）
- Auto Layout 约束更新时
- 设备旋转时（`viewWillTransition`）
- 视图的 `bounds` 改变时（如果 `autoresizesSubviews` 为 true）

**在我们的 UIButton 例子中**：
- `view.addSubview(button)` → 系统会自动标记 button 需要布局
- 即使不显式调用 `setNeedsLayout`，系统也会在 RunLoop 结束前自动执行布局

---

### t2：Display 阶段（生成 bitmap）

**时间点**：Layout 阶段之后，RunLoop 进入休眠前

**触发时机**：
- RunLoop 的 `kCFRunLoopBeforeWaiting` 阶段
- 或者手动调用 `displayIfNeeded()` 时

**这个阶段发生了什么**：

1. **检查哪些 Layer 需要 Display**
   - 系统检查所有被标记为"需要显示"的 Layer
   - `setNeedsDisplay` 标记的 Layer 会被处理
   - **只有被标记的 Layer 才会执行 Display**

2. **系统自动标记 Display 的情况**（不需要手动调用 `setNeedsDisplay`）：
   - 视图被添加到父视图时（`addSubview`）→ **自动标记**
   - 修改 Layer 的可视属性时（如 `backgroundColor`、`cornerRadius` 等）→ **自动标记**
   - 修改 `contents` 属性时 → **自动标记**
   - 修改 `bounds` 时（如果 Layer 有 contents）→ **自动标记**

3. **CALayer 的 display 方法被调用**
   - 对于被标记的 Layer，系统会调用 `display(_:)` 方法
   - 这个方法负责生成 bitmap 并存入 `contents`

4. **三种不同的 Display 路径**（以我们的 UIButton 为例）：

   **路径 A：UIButton 自身的 Layer（没有 contents）**
   - 只设置了 `backgroundColor`、`cornerRadius` 等属性
   - **不生成 bitmap**，`contents` 保持为 nil
   - GPU 会根据这些属性直接渲染几何图形
   - 不需要 CPU 绘制

   **路径 B：UIImageView 的 Layer（图片 → bitmap）**
   - `setImage:` 时，图片文件（PNG/JPEG）已经在内存中
   - Display 阶段：**图片解码成 bitmap**
     - PNG/JPEG 是压缩格式，需要解码成未压缩的 bitmap
     - 解码后的 bitmap 赋值给 `layer.contents`
   - **关键**：图片解码是 CPU 操作，在主线程执行（可能阻塞）
   - bitmap 大小 = 图片宽 × 高 × 4 字节（RGBA）

   **路径 C：UILabel 的 Layer（文字 → bitmap）**
   - `setTitle:` 时，文字内容已经设置
   - Display 阶段：**Core Text 排版 + 光栅化**
     - Core Text 根据字体、字号、行距等属性进行排版
     - 排版结果（文字轮廓）光栅化成 bitmap
     - bitmap 存入 `layer.contents`
   - **关键**：文字排版和光栅化是 CPU 操作，在主线程执行
   - bitmap 大小 = Label 的 bounds 大小 × 4 字节（RGBA）

   ---

   #### ❓ 问题 5：光栅化到底是在干嘛？

   **回答**：

   **光栅化（Rasterization）**：将矢量图形转换成位图（bitmap）的过程。

   **通俗理解**：
   - **矢量图形**：用数学公式描述的图形（如文字轮廓、Bezier 曲线）
     - 优点：可以无限放大不失真
     - 缺点：GPU 无法直接渲染，需要先转换成像素
   - **位图（bitmap）**：由像素点组成的图像
     - 优点：GPU 可以直接渲染
     - 缺点：放大后会模糊

   **在 UILabel 中的光栅化过程**：

   1. **Core Text 排版**（矢量阶段）
      - 根据字体文件（TTF/OTF）中的轮廓数据，计算出文字的矢量轮廓
      - 轮廓是数学曲线，不是像素
      - 例如：字母 "A" 的轮廓是几条 Bezier 曲线

   2. **光栅化**（矢量 → 位图）
      - 将矢量轮廓"填充"成像素点
      - 根据 Label 的 bounds 大小，创建一个像素网格
      - 判断每个像素点是否在文字轮廓内
      - 如果在轮廓内，就填充颜色（通常是黑色）
      - 如果在轮廓边缘，可能做抗锯齿处理（半透明像素）
      - 最终得到一个 bitmap（像素矩阵）

   3. **存入 contents**
      - 光栅化后的 bitmap 存入 `layer.contents`
      - GPU 可以直接读取这个 bitmap 进行渲染

   **为什么需要光栅化**：
   - GPU 擅长渲染位图（纹理），不擅长渲染矢量图形
   - 文字轮廓是矢量，必须转换成位图才能让 GPU 渲染
   - 光栅化是 CPU 的工作，在主线程执行

   **类比**：
   - 矢量图形 = 用数学公式画的画（可以无限放大）
   - 光栅化 = 把数学公式的画"拍照"成像素照片
   - 位图 = 像素照片（GPU 可以直接显示）

   ---

   #### ❓ 问题 6：位图是什么？纹理又是什么？它们的关系是什么？

   **回答**：

   **位图（Bitmap）**：
   - **定义**：由像素点组成的图像数据
   - **存储格式**：二维数组，每个元素是一个像素的颜色值（RGBA）
   - **特点**：
     - 有固定的宽度和高度
     - 每个像素占用 4 字节（RGBA，每个通道 1 字节）
     - 总大小 = 宽 × 高 × 4 字节
   - **例子**：
     - 100×100 的位图 = 10000 个像素 = 40000 字节（约 39 KB）
     - 1000×1000 的位图 = 1000000 个像素 = 4000000 字节（约 3.8 MB）

   **纹理（Texture）**：
   - **定义**：GPU 内存中的图像数据
   - **本质**：位图上传到 GPU 内存后，就变成了纹理
   - **特点**：
     - GPU 可以直接读取和渲染
     - 存储在 GPU 的显存中
     - GPU 渲染时，会从纹理中采样像素颜色

   **它们的关系**：
   - **位图**：CPU 内存中的图像数据（`layer.contents` 存储的就是位图）
   - **纹理**：GPU 内存中的图像数据（位图上传到 GPU 后变成纹理）
   - **转换过程**：
     ```
     CPU 内存（位图） → 上传到 GPU → GPU 内存（纹理） → GPU 渲染
     ```

   **在 iOS 绘制流程中**：
   1. **t2 阶段（Display）**：生成位图，存入 `layer.contents`（CPU 内存）
     - UILabel：文字光栅化成位图
     - UIImageView：图片解码成位图
   
   2. **t3 阶段（Commit）**：位图数据随 Layer 信息一起提交到 Render Server
   
   3. **t4 阶段（Render Server）**：位图上传到 GPU 内存，变成纹理
   
   4. **t5 阶段（GPU 渲染）**：GPU 从纹理中采样像素，进行渲染

   **通俗理解**：
   - **位图** = 电脑内存里的图片数据（CPU 能处理）
   - **纹理** = GPU 显存里的图片数据（GPU 能渲染）
   - **上传** = 把位图从 CPU 内存复制到 GPU 显存

   **为什么叫"纹理"**：
   - 在 3D 图形学中，纹理是用来"贴"在 3D 模型表面的图像
   - 在 2D 渲染中，纹理就是用来渲染的图像数据
   - 名字来自 3D 图形学，但概念是一样的

   ---

5. **CALayer 的 display 方法调用**

   `[CALayer display]` 方法被调用时，会根据 delegate 的实现情况，走不同的绘制路径：

   **路径判断**：
   - `display` 方法内部会先判断 layer 的 delegate 是否会响应 `displayLayer:` 方法
   - 如果**不响应** → 进入**系统绘制流程**
   - 如果**响应** → 进入**异步绘制入口**（可以自定义异步绘制）

6. **系统绘制流程**（默认路径）

   **触发条件**：delegate 没有实现 `displayLayer:` 方法

   **流程**：
   1. 创建 backing storage（CGContextRef）
      - 每个 layer 都会有一个 context
      - 这个 context 指向一块缓存区，被称为 backing store
   2. 调用绘制方法
      - 如果 layer 有 delegate，调用 `drawLayer:inContext:` 方法
      - 否则调用 `drawInContext:` 方法，进而调用 `[UIView drawRect:]` 方法
   3. 在 CGContextRef 环境中绘制
      - `drawRect:` 方法在 CPU 执行
      - 通过 `UIGraphicsGetCurrentContext()` 可以获取到 CALayer 创建的 CGContextRef
      - 绘制的内容写入 backing store
   4. 生成 bitmap
      - `drawRect:` 执行完后，通过 context 将数据写入 backing store
      - 最终结果是一个 bitmap（CGImageRef）
      - bitmap 存入 `layer.contents`

   **关键点**：
   - **只有覆写了 `drawRect:` 方法时，才会走系统绘制流程**
   - 绝大多数情况下（如设置 `backgroundColor`、使用 `UIImageView`、设置 `UILabel` 的文本等），**不走 `drawRect:`**
   - 一旦覆写 `drawRect:`，系统会为该 View 申请一块巨大的内存（backing store）
   - 内存大小 = width × height × contentsScale² × 4 字节，**极其耗费内存**

7. **异步绘制入口**（自定义路径）

   **触发条件**：delegate 实现了 `displayLayer:` 方法

   **作用**：提供了异步绘制的入口，可以在后台线程进行绘制

   **流程**：
   1. `display` 方法检测到 delegate 实现了 `displayLayer:`
   2. 可以自定义异步绘制逻辑：
      - 在后台线程创建 CGContextRef
      - 在后台线程进行绘制
      - 绘制完成后，在主线程设置 `layer.contents`
   3. **优势**：
      - 不阻塞主线程
      - 适合复杂绘制场景（如大量文本、复杂图形）

   **注意**：
   - 这是自定义的异步绘制，不是系统默认行为
   - 需要开发者自己实现 `displayLayer:` 方法
   - UIKit 的绘制 API 是线程安全的，可以在后台线程使用

   **异步绘制实现示例**（精简版）：

   ```objectivec
   // 自定义 CALayer，实现异步绘制
   @interface AsyncLayer : CALayer
   @property (atomic, assign) BOOL isDrawing;  // 绘制状态标记
   @end

   @implementation AsyncLayer

   - (void)setNeedsDisplay {
       // 收到新的绘制请求时，取消正在绘制的线程
       self.isDrawing = NO;
       [super setNeedsDisplay];
   }

   - (void)display {
       // 判断 delegate 是否实现了 displayLayer: 方法
       if ([self.delegate respondsToSelector:@selector(displayLayer:)]) {
           // ✅ 走异步绘制入口
           [self asyncDraw];
       } else {
           // ❌ 走系统绘制流程
           [super display];
       }
   }

   - (void)asyncDraw {
       self.isDrawing = YES;
       
       // 在后台线程进行绘制
       dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
           
           // 检查是否被取消
           if (!self.isDrawing) return;
           
           // 1. 创建绘制上下文（后台线程）
           CGSize size = self.bounds.size;
           CGFloat scale = [UIScreen mainScreen].scale;
           UIGraphicsBeginImageContextWithOptions(size, self.opaque, scale);
           CGContextRef context = UIGraphicsGetCurrentContext();
           
           // 2. 设置背景色（如果需要）
           if (self.opaque && self.backgroundColor) {
               CGContextSetFillColorWithColor(context, self.backgroundColor);
               CGContextFillRect(context, CGRectMake(0, 0, size.width * scale, size.height * scale));
           }
           
           // 3. 调用 delegate 的绘制方法（后台线程）
           if ([self.delegate respondsToSelector:@selector(drawLayer:inContext:)]) {
               [self.delegate drawLayer:self inContext:context];
           }
           
           // 4. 检查是否被取消
           if (!self.isDrawing) {
               UIGraphicsEndImageContext();
               return;
           }
           
           // 5. 从上下文生成图片
           UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
           UIGraphicsEndImageContext();
           
           // 6. 在主线程设置 contents
           dispatch_async(dispatch_get_main_queue(), ^{
               if (self.isDrawing) {
                   self.contents = (__bridge id)(image.CGImage);
               }
           });
       });
   }

   @end
   ```

   **关键点**：
   - `display` 方法中判断 delegate 是否实现了 `displayLayer:`，决定走哪个路径
   - 异步绘制在后台线程创建 context 并绘制
   - 绘制完成后，必须在主线程设置 `layer.contents`
   - 需要处理取消逻辑，避免重复绘制

**系统绘制 vs 异步绘制**：

| 特性 | 系统绘制（drawRect） | 异步绘制（displayLayer） |
|------|---------------------|-------------------------|
| 触发条件 | delegate 没有实现 `displayLayer:` | delegate 实现了 `displayLayer:` |
| 执行线程 | 主线程 | 可以后台线程 |
| 内存消耗 | 大（backing store） | 大（backing store） |
| 使用场景 | 默认路径，简单绘制 | 复杂绘制，需要性能优化 |
| 是否阻塞主线程 | 是 | 否（如果实现得当） |

**关键点**：
- Display 阶段**生成 bitmap**，存入 Layer 的 `contents`
- **不是所有 Layer 都需要生成 bitmap**：有些 Layer 没有 contents，GPU 直接渲染
- **图片解码和文字光栅化是 CPU 操作**：在主线程执行，可能阻塞
- **bitmap 大小影响内存**：大图片会占用大量内存

**Display 和 Layout 的区别**：
- **Layout**：计算位置和大小（"在哪里显示"、"显示多大"）
- **Display**：生成显示内容（"显示什么"）

**标记机制**：
- `setNeedsDisplay` → 标记需要显示（手动标记）
- `displayIfNeeded` → 立即执行显示（同步）
- RunLoop 结束前 → 自动执行所有标记的显示（异步）

**在我们的 UIButton 例子中**：
- `view.addSubview(button)` → 系统会自动标记所有 Layer 需要 Display
- UIButton 自身的 Layer：不生成 bitmap，contents 为 nil
- UIImageView 的 Layer：图片解码成 bitmap，存入 contents
- UILabel 的 Layer：文字光栅化成 bitmap，存入 contents

---

#### ❓ 问题 12：系统绘制和异步绘制是什么意思？

**问题描述**：
文章提到了异步绘制入口和系统绘制，都是什么意思？

**回答**：

**CALayer 的 display 方法流程（代码流程图）**：

```swift
// CALayer 的 display 方法（简化版伪代码）
func display() {
    // 第一步：判断 delegate 是否实现了 displayLayer: 方法
    if delegate?.responds(to: #selector(displayLayer(_:))) == true {
        // ✅ 路径 A：异步绘制入口
        // delegate 实现了 displayLayer:，走异步绘制路径
        delegate?.displayLayer(self)
        // 注意：这里 delegate 可以自定义实现，在后台线程绘制
        return
    }
    
    // ❌ 路径 B：系统绘制流程（默认路径）
    // delegate 没有实现 displayLayer:，走系统绘制流程
    
    // 1. 创建 backing store（CGContextRef）
    let context = createBackingStore()  // 创建 CGContextRef
    
    // 2. 判断是否有 delegate 实现了 drawLayer:inContext: 方法
    if delegate?.responds(to: #selector(drawLayer(_:inContext:))) == true {
        // 2a. 调用 delegate 的 drawLayer:inContext: 方法
        delegate?.drawLayer(self, inContext: context)
    } else {
        // 2b. 调用 Layer 自己的 drawInContext: 方法
        self.drawInContext(context)
        // drawInContext: 内部会调用 UIView 的 drawRect: 方法（如果 UIView 是 delegate）
    }
    
    // 3. 绘制完成后，从 context 生成 bitmap
    let image = createImageFromContext(context)
    
    // 4. 存入 layer.contents
    self.contents = image
}

// UIView 作为 CALayer 的 delegate，drawInContext: 会调用 drawRect:
func drawInContext(_ context: CGContext) {
    // UIView 是 Layer 的 delegate
    if let view = self.delegate as? UIView {
        // 判断 UIView 是否覆写了 drawRect: 方法
        if view.responds(to: #selector(draw(_:))) {
            // 只有覆写了 drawRect:，才会调用
            view.drawRect(self.bounds)
        } else {
            // 如果没有覆写 drawRect:，不会调用
            // 系统会直接使用 layer 的其他属性（backgroundColor、contents 等）
        }
    }
}
```

**流程图总结**（修正版）：

```
[CALayer display] 被触发
    │
    ├── 1. 拦截检查：delegate 是否实现了 displayLayer:?
    │   │
    │   ├── 是 (路径 A：完全自定义/异步绘制入口)
    │   │   │
    │   │   └── 执行 delegate.displayLayer(layer)
    │   │       │
    │   │       └── 结论：系统完全放手，不创建上下文，不调用 drawRect。
    │   │           开发者必须手动给 layer.contents 赋值（UIImage.cgImage）。
    │   │           (典型应用：AsyncDisplayKit、YYText 的异步绘制逻辑)
    │   │
    │   └── 否 (路径 B：系统接管流程)
    │       │
    │       └── 2. 关键判定：是否需要 CPU 绘图？
    │           (系统检查：是否覆写了 drawRect: 或 drawLayer:inContext:？)
    │           │
    │           ├── 否 (不需要 CPU 绘图)
    │           │   │
    │           │   └── 3. 进一步判断：是否存在已有内容？
    │           │       │
    │           │       ├── 是 (已有 contents)
    │           │       │   │
    │           │       │   └── 直接使用已有 contents 位图
    │           │       │       (例如：UIImageView.image、手动设置过 contents)
    │           │       │
    │           │       └── 否 (没有 contents)
    │           │           │
    │           │           └── 4. 判断：是否有样式属性？
    │           │               │
    │           │               ├── 是 (有 backgroundColor / border / corner 等)
    │           │               │   │
    │           │               │   └── GPU 属性渲染路径
    │           │               │       不创建 Backing Store，不产生位图内存
    │           │               │       GPU 根据 backgroundColor 等属性直接着色
    │           │               │       (这是 90% 普通 UIView 的状态，内存开销极低)
    │           │               │
    │           │               └── 否 (没有任何样式属性)
    │           │                   │
    │           │                   └── Layer 完全透明/无内容
    │           │
    │           └── 是 (降级路径：CPU 位图绘制)
    │               │
    │               ├── ① 创建 Backing Store (开辟内存：宽 * 高 * 4 字节)
    │               │
    │               ├── ② 调用绘图链条
    │               │   │
    │               │   ├── 优先：delegate.drawLayer:inContext:
    │               │   │
    │               │   └── 其次：layer.drawInContext:
    │               │       │
    │               │       └── 若 delegate 是 UIView：
    │               │           内部触发 UIView.drawRect(rect)
    │               │
    │               ├── ③ 绘制完成，渲染生成位图 (CGImageRef)
    │               │
    │               ├── ④ 赋值：layer.contents = bitmap
    │               │
    │               └── ⑤ 销毁上下文 (释放临时绘制资源)
```

**重要修正**：
- **Gemini 的流程更准确**：系统会先判断是否需要 CPU 绘图，如果不需要就不创建 Backing Store
- **我之前说的"先创建 Backing Store 再判断"是错误的**：实际上系统会先检查是否需要 CPU 绘图，只有需要时才创建 Backing Store

**关键点说明**（修正版）：

1. **第一个判断**：`displayLayer:` 方法
   - 如果实现了 → 走**完全自定义/异步绘制入口**（路径 A）
     - 系统完全放手，不创建上下文，不调用 drawRect
     - 开发者必须手动给 `layer.contents` 赋值
   - 如果没实现 → 走**系统接管流程**（路径 B）

2. **系统接管流程中的关键判定**：是否需要 CPU 绘图？
   - **系统会先检查**：是否覆写了 `drawRect:` 或实现了 `drawLayer:inContext:`
   - **如果不需要 CPU 绘图**（极速路径）：
     - 不创建 Backing Store，不产生位图内存
     - 直接结束，GPU 根据 `backgroundColor` 等属性直接着色
     - **这是 90% 普通 UIView 的状态，内存开销极低**
   - **如果需要 CPU 绘图**（降级路径）：
     - 创建 Backing Store（开辟内存：宽 × 高 × 4 字节）
     - 调用绘图链条（`drawLayer:inContext:` 或 `drawRect:`）
     - 生成位图，存入 `layer.contents`

3. **drawRect: 的调用条件（唯一路径）**：
   - ✅ delegate 没有实现 `displayLayer:`（否则走异步绘制）
   - ✅ 系统判定需要 CPU 绘图（覆写了 `drawRect:` 或实现了 `drawLayer:inContext:`）
   - ✅ delegate 没有实现 `drawLayer:inContext:`（否则走 drawLayer:inContext:）
   - ✅ delegate 是 UIView（否则不会调用 drawRect:）
   - ✅ UIView **覆写了** `drawRect:` 方法
   - **结论：只有同时满足以上所有条件，才会调用 `drawRect:`**

4. **如果 UIView 没有覆写 drawRect: 会怎样？**
   - 系统在 `display` 阶段就判定：不需要 CPU 绘图
   - **不会创建 Backing Store，不会走 CPU 绘制流程**
   - 系统会直接使用 layer 的其他属性（如 `backgroundColor`、`contents` 等）
   - GPU 根据这些属性直接渲染，内存开销极低

5. **UIView 的特殊性**：
   - UIView 是 CALayer 的 delegate
   - 当调用 `drawInContext:` 时，如果 delegate 是 UIView，且覆写了 `drawRect:`，才会调用 `drawRect:`
   - 在 `drawRect:` 中，可以通过 `UIGraphicsGetCurrentContext()` 获取到 Layer 创建的 CGContextRef

**重要结论**：
- **只有一种情况会走 `drawRect:`**：delegate 是 UIView，且没有实现 `displayLayer:` 和 `drawLayer:inContext:`，且 UIView 覆写了 `drawRect:`
- **绝大多数情况不走 `drawRect:`**：
  - UIImageView、UILabel 等系统控件：直接使用 `contents`（图片、文字光栅化后的 bitmap）
  - 自定义 Layer 实现了 `displayLayer:`：走异步绘制
  - 自定义 Layer 实现了 `drawLayer:inContext:`：走自定义绘制

**实际例子**：

```swift
// 例子 1：普通 UIView（覆写了 drawRect:）
class MyView: UIView {
    override func draw(_ rect: CGRect) {
        // 这里会走系统绘制流程
        // display → drawInContext: → drawRect:
        let context = UIGraphicsGetCurrentContext()
        // 绘制...
    }
}
// 流程：display → drawInContext: → drawRect:

// 例子 2：自定义 Layer（实现了 displayLayer:）
class AsyncLayer: CALayer {
    override class func defaultAction(forKey event: String) -> CAAction? {
        return nil
    }
}

class AsyncLayerDelegate: NSObject, CALayerDelegate {
    func display(_ layer: CALayer) {
        // 这里走异步绘制入口
        // 可以在后台线程绘制
        DispatchQueue.global().async {
            let context = createContext()
            // 绘制...
            let image = createImage(from: context)
            DispatchQueue.main.async {
                layer.contents = image
            }
        }
    }
}
// 流程：display → displayLayer:（自定义异步绘制）

// 例子 3：普通 UIView（没有覆写 drawRect:）
class NormalView: UIView {
    // 没有覆写 drawRect:
    // 只设置了 backgroundColor
}
let view = NormalView()
view.backgroundColor = UIColor.blue
// 流程：display → drawInContext: → 检查到没有覆写 drawRect: → 不调用 drawRect:
// 系统直接使用 layer.backgroundColor，不走 CPU 绘制流程

// 例子 4：UIImageView（不走 drawRect:）
let imageView = UIImageView(image: UIImage(named: "icon"))
// 流程：直接使用 image 的 CGImage，不走 display 流程
// image 解码后直接存入 layer.contents
```

**关键理解**：
- **系统绘制**：系统默认的绘制流程，通过 `drawRect:` 实现
- **异步绘制**：自定义的绘制流程，通过 `displayLayer:` 实现，可以在后台线程执行
- **绝大多数情况不走系统绘制**：UIImageView、UILabel 等系统控件不走 `drawRect:`，而是直接使用 `contents`（图片、文字光栅化后的 bitmap）

---

### t3：CATransaction Commit 阶段（提交到 Render Server）

**时间点**：Display 阶段之后，RunLoop 进入休眠前

**触发时机**：
- RunLoop 的 `kCFRunLoopBeforeWaiting` 阶段
- 或者手动调用 `CATransaction.commit()` 时

**这个阶段发生了什么**：

1. **CATransaction 的作用**
   - CATransaction 是 Core Animation 的事务机制
   - 用于批量处理多个 Layer 的更新，统一提交到 Render Server
   - 每个 RunLoop 周期会自动创建一个隐式事务

2. **收集所有需要提交的 Layer**
   - 系统收集所有被标记为"需要提交"的 Layer
   - 包括所有在 t0、t1、t2 阶段被修改的 Layer

3. **三种 Layer 树的关系**

   iOS 中有三种 Layer 树，它们在不同阶段发挥作用：

   **Model Tree（模型树）**：
   - **存在时间**：t0 阶段开始，一直存在
   - **位置**：应用进程内存中
   - **作用**：存储 Layer 的最终状态（你设置的属性值）
   - **特点**：
     - 这是应用层直接操作的树
     - `view.layer` 访问的就是 Model Tree
     - 属性值是你设置的值，不考虑动画中间状态
   - **例子**：
     ```swift
     button.frame = CGRect(x: 100, y: 100, width: 200, height: 50)
     // Model Tree 中这个 Layer 的 frame 就是 (100, 100, 200, 50)
     ```

   **Presentation Tree（呈现树）**：
   - **存在时间**：动画进行时
   - **位置**：应用进程内存中
   - **作用**：存储 Layer 的当前显示状态（动画的中间值）
   - **特点**：
     - 只在动画时存在，用于获取动画过程中的值
     - 通过 `layer.presentation()` 访问
     - 属性值是动画的中间插值
   - **例子**：
     ```swift
     UIView.animate(withDuration: 1.0) {
         button.frame = CGRect(x: 200, y: 200, width: 200, height: 50)
     }
     // 动画过程中，Presentation Tree 中的 frame 会从 (100,100,200,50) 逐渐变化到 (200,200,200,50)
     // Model Tree 中的 frame 立即变成 (200,200,200,50)
     ```

   **Render Tree（渲染树）**：
   - **存在时间**：t3 阶段构建，提交到 Render Server
   - **位置**：Render Server 进程内存中
   - **作用**：存储需要渲染的所有信息
   - **特点**：
     - 根据 Model Tree（或动画时的 Presentation Tree）构建
     - 包含所有渲染所需的数据（几何属性、视觉属性、层级关系）
     - 序列化后发送到 Render Server
   - **构建时机**：t3 阶段（CATransaction Commit）

   **三种树的关系**：
   ```
   t0-t2: Model Tree（应用层设置属性）
        ↓
   t3:    根据 Model Tree 构建 Render Tree
        ↓
   t3:    Render Tree 序列化，发送到 Render Server
        ↓
   t4+:   Render Server 使用 Render Tree 进行渲染
   
   动画时：
   Model Tree（最终值） → Presentation Tree（中间值） → Render Tree（渲染）
   ```

4. **构建 Render Tree**
   - 根据 Model Tree（应用层的 Layer 树）构建 Render Tree
   - Render Tree 包含所有需要渲染的信息：
     - Layer 的几何属性（position、bounds、transform 等）
     - Layer 的视觉属性（backgroundColor、contents、opacity 等）
     - Layer 的层级关系

4. **序列化 Layer 数据**
   - 将 Render Tree 序列化成二进制数据
   - 通过 IPC（进程间通信）发送到 Render Server（backboardd 进程）

5. **提交到 Render Server**
   - Render Server 是独立的进程（backboardd）
   - 应用进程和 Render Server 进程分离，提高稳定性
   - 即使应用崩溃，Render Server 仍能继续渲染

**关键点**：
- Commit 阶段**不进行实际渲染**，只是提交数据
- Render Server 是独立进程，与应用进程分离
- 所有 Layer 的更新会批量提交，提高效率

**在我们的 UIButton 例子中**：
- 三个 Layer（UIButton 自身、UIImageView、UILabel）的更新数据
- 会被统一收集，构建成 Render Tree
- 序列化后通过 IPC 发送到 Render Server

---

#### ❓ 问题 7：三种 Layer 树分别在哪个阶段？

**回答**：

**Model Tree（模型树）**：
- **t0 阶段**：创建 Layer，添加到 Model Tree
- **t0-t2 阶段**：修改 Layer 属性，更新 Model Tree
- **一直存在**：Model Tree 在整个应用生命周期都存在
- **位置**：应用进程内存中

**Presentation Tree（呈现树）**：
- **动画时**：系统根据 Model Tree 和动画参数生成 Presentation Tree
- **只在动画时存在**：没有动画时，Presentation Tree 不存在
- **位置**：应用进程内存中
- **作用**：存储动画的中间插值

---

#### ❓ 问题 9：动画是 60 FPS，RunLoop 是不是每秒要休眠 60 次？

**问题描述**：
动画频率很高（60 FPS），每秒 60 帧。如果渲染是在 RunLoop 休眠前，那 RunLoop 岂不是一秒要休眠 60 次？

**回答**：

**关键误解**：动画的每一帧渲染**不是**由 RunLoop 驱动的！

**实际情况**：

1. **RunLoop 的提交时机**
   - RunLoop 在休眠前（`kCFRunLoopBeforeWaiting`）会提交一次渲染
   - 但这是**一次性提交**，不是每帧都提交
   - 提交的是**动画的开始状态和结束状态**，以及动画参数（时长、曲线等）

2. **动画的持续渲染**
   - 动画开始后，**Render Server 会持续渲染**
   - Render Server 根据 VSync 信号（每秒 60 次）进行渲染
   - **VSync 驱动渲染**，不是 RunLoop 驱动
   - Render Server 会根据动画参数，每一帧计算中间值并渲染

3. **动画时的流程**：
   ```
   t0: 代码执行，设置动画
   t1-t2: Layout 和 Display（如果需要）
   t3: 提交动画到 Render Server
      - 提交起始值、结束值、动画参数（时长、曲线等）
      - 不是提交每一帧的值！
   
   动画开始后（Render Server 端）：
   VSync 信号 1 → Render Server 计算第 1 帧的中间值 → GPU 渲染
   VSync 信号 2 → Render Server 计算第 2 帧的中间值 → GPU 渲染
   VSync 信号 3 → Render Server 计算第 3 帧的中间值 → GPU 渲染
   ...
   VSync 信号 60 → Render Server 计算第 60 帧的中间值 → GPU 渲染
   
   （注意：Render Server 计算的中间值不是 Presentation Tree，而是 Render Tree 的中间值）
   ```

4. **RunLoop 和动画的关系**：
   - **RunLoop 只负责提交动画的开始**（一次提交）
   - **Render Server 负责持续渲染**（60 次/秒）
   - **VSync 信号驱动渲染频率**（60 FPS）

5. **为什么这样设计**：
   - 如果每帧都通过 RunLoop 提交，会非常低效
   - 一次性提交动画参数，Render Server 自己计算中间值
   - Render Server 是独立进程，不受应用进程的 RunLoop 影响
   - VSync 信号保证渲染和屏幕刷新同步

**总结**：
- **RunLoop 不是每秒休眠 60 次**
- **RunLoop 只提交一次动画**（起始值、结束值、参数）
- **Render Server 根据 VSync 信号持续渲染**（60 次/秒）
- **VSync 驱动渲染频率**，不是 RunLoop

**类比**：
- RunLoop = 发送一个"动画指令"给 Render Server
- Render Server = 收到指令后，自己按照 VSync 节奏持续渲染
- VSync = 节拍器，每秒 60 次，控制渲染节奏

---

#### ❓ 问题 10：Render Server 计算的中间值是 Presentation Tree 吗？

**问题描述**：
Render Server 计算第 2 帧的中间值，这个计算的是 Presentation Tree 的中间值吗？

**回答**：

**不是！** Render Server 计算的中间值**不是** Presentation Tree。

**关键区别**：

1. **Presentation Tree**：
   - **位置**：应用进程内存中
   - **作用**：存储动画的中间值，供应用层查询（如 `layer.presentation()`）
   - **计算时机**：应用进程端，可能不是每帧都计算
   - **访问方式**：通过 `layer.presentation()` 访问

2. **Render Server 计算的中间值**：
   - **位置**：Render Server 进程内存中
   - **作用**：用于构建 Render Tree，进行实际渲染
   - **计算时机**：Render Server 端，每一帧都计算（根据 VSync）
   - **访问方式**：应用进程无法直接访问

**实际流程**：

```
应用进程端：
t0-t2: Model Tree 更新（设置动画的最终值）
t3: 提交动画参数到 Render Server
     - 起始值、结束值、时长、曲线等
     - 可能同时提交 Presentation Tree（用于应用层查询）

Render Server 端：
VSync 信号 1 → Render Server 根据动画参数计算第 1 帧的中间值
            → 构建 Render Tree（第 1 帧）
            → GPU 渲染

VSync 信号 2 → Render Server 根据动画参数计算第 2 帧的中间值
            → 构建 Render Tree（第 2 帧）
            → GPU 渲染
```

**为什么有两个中间值**：

1. **Presentation Tree（应用进程）**：
   - **本质**：是 Render Server 中当前帧状态在 App 进程中的**投影**
   - **计算时机**：不是每帧都计算，而是当你访问 `layer.presentation()` 时才查询
   - **作用**：供应用层查询当前动画状态
   - **例子**：`layer.presentation().frame` 获取当前显示的 frame
   - **访问方式**：通过 `layer.presentation()` 访问

2. **Render Server 计算的中间值（Render Server 进程）**：
   - **本质**：Render Server 根据动画参数（剧本）自己计算的
   - **计算时机**：每一帧都计算（根据 VSync）
   - **作用**：用于构建 Render Tree，进行实际渲染
   - **访问方式**：应用进程无法直接访问

**总结**：
- **Presentation Tree**：应用进程端，是查询接口（镜像投影），不是每帧计算提交的
- **Render Server 计算的中间值**：Render Server 端，用于实际渲染，每一帧都计算
- **它们是分开的**：Render Server 不依赖 Presentation Tree，自己根据动画参数计算中间值
- **关键**：即使主线程卡顿，Render Server 依然能独立计算和渲染，动画不会掉帧

---

#### ❓ 问题 11：动画过程中的位置不是由 Presentation Tree 决定的吗？

**问题描述**：
动画过程中的时机位置不是由 Presentation Tree 决定的吗？难道我要先算好一组 Presentation Tree 的值？如果不是每帧都算的话，我不理解了。

**回答**：

**核心结论：Render Server 才是计算中心**

动画开始后，**App 进程只提交一次**，剩下的活儿全是 **Render Server** 的。

**正确的流程**：

1. **App 进程（t3 阶段）**：
   - 把动画的"剧本"（起始值、终点值、时长、插值曲线函数）打包成一个 `CATransaction` 发送给 Render Server
   - **只提交一次**

2. **Render Server（动画过程中）**：
   - 它是独立进程，内部有一个由 VSync 驱动的计时器
   - 每一帧根据"剧本"公式，自己计算出当前时刻位图应该在哪个坐标
   - 直接命令 GPU 绘制
   - **不依赖 App 进程的每帧计算**

3. **App 进程（动画过程中）**：
   - 不需要参与每一帧的计算
   - 即使主线程被卡死（比如执行死循环），**动画依然会流畅地运行**

**反证法**：
- 如果 Presentation Tree 需要 App 进程每帧计算并提交，那么只要主线程卡顿 16ms，动画就会立刻掉帧
- 但事实是，很多 CA 动画在主线程卡顿时依然不跳帧
- 这就是因为 Render Server 在独立运作

**Presentation Tree 的真正作用**：

**它的本质**：它是一个**"镜像查询接口"**。

- **计算时机**：它不是被主动"计算"出来提交的，而是当你访问 `layer.presentation()` 时，UIKit 才去向 Render Server 询问（或者根据时间戳本地推算）："喂，现在那个动画跑到哪儿了？"然后返回给你一个当时的快照
- **用途**：主要用于处理交互。比如一个移动的按钮，你点击时，需要知道它**此刻**在屏幕的什么位置，这时才去查 Presentation Tree

**两种动画的本质区别**：

#### **A. Core Animation 动画（显式或隐式动画）**

- **提交次数**：**1 次**（提交剧本）
- **执行者**：Render Server
- **结论**：不依赖 App 进程的每帧计算
- **例子**：`UIView.animate`、`CABasicAnimation` 等

#### **B. 基于 CADisplayLink 的手动动画**

如果你手动写了 `CADisplayLink`，并在回调里每帧修改 `view.center`：

- **提交次数**：**每秒 60/120 次**
- **执行者**：App 进程（主线程）
- **结论**：这种情况下，App 进程每帧都计算和提交，但这不是系统原生 CA 动画的逻辑，且这种做法非常消耗 CPU 性能

**修正后的理解**：

- **Render Server 职责**：负责动画的**插值计算**。它根据 VSync 信号，实时根据动画公式更新 Render Tree 的属性
- **Presentation Tree 职责**：是 Render Server 中当前帧状态在 App 进程中的**投影**。它主要用于开发者在动画过程中读取图层的"实时位置"
- **同步机制**：动画开始时，App 进程将 Model Tree 的终点值设好，并把动画描述发送给 Render Server。两者在动画期间是**分离**的

**总结**：
- **Render Server 才是"大脑"**，负责动画的每一帧计算
- **App 进程只提交一次**动画参数（剧本）
- **Presentation Tree** 是查询接口，不是每帧计算提交的
- **即使主线程卡顿，动画依然流畅**，因为 Render Server 独立运作

---

### t4：Render Server 处理阶段（准备渲染）

**时间点**：t3 阶段提交数据后，Render Server 接收并处理

**触发时机**：
- Render Server 收到应用进程提交的 Render Tree 数据
- Render Server 是独立进程（backboardd），有自己的处理流程

**这个阶段发生了什么**：

1. **接收 Render Tree 数据**
   - Render Server 通过 IPC 接收序列化的 Render Tree 数据
   - 反序列化，重建 Render Tree 结构
   - Render Tree 包含所有需要渲染的 Layer 信息

2. **处理位图数据（如果有 contents）**
   - 对于有 `contents` 的 Layer（如 UIImageView、UILabel）
   - Render Server 需要将位图数据上传到 GPU 内存
   - **位图 → 纹理**：位图从 CPU 内存复制到 GPU 显存，变成纹理
   - GPU 可以直接读取纹理进行渲染

3. **准备渲染数据**
   - 根据 Render Tree 构建渲染命令
   - 包括：
     - Layer 的几何信息（position、bounds、transform）
     - Layer 的视觉属性（backgroundColor、opacity、contents/纹理）
     - Layer 的层级关系（z-order）
     - 渲染顺序和混合模式

4. **等待 VSync 信号**
   - Render Server 准备好渲染数据后，等待 VSync 信号
   - VSync 信号由显示硬件发出，每秒 60 次（或 120 次，取决于设备）
   - VSync 信号表示"屏幕准备好显示新的一帧"

**关键点**：
- Render Server 是独立进程，不受应用进程影响
- 位图上传到 GPU 是异步操作，不阻塞应用进程
- Render Server 准备好数据后，等待 VSync 信号才开始渲染

**在我们的 UIButton 例子中**：
- Render Server 收到三个 Layer 的数据
- UIImageView 的 Layer：位图上传到 GPU，变成纹理
- UILabel 的 Layer：位图上传到 GPU，变成纹理
- UIButton 自身的 Layer：没有位图，只有几何和视觉属性

**位图上传的时机**：
- **非动画情况**：t4 阶段上传位图到 GPU
- **动画情况**：位图在动画开始前上传一次，动画过程中只更新几何属性（position、transform 等），不重新上传位图

---

### t5：GPU 渲染阶段（渲染到屏幕）

**时间点**：VSync 信号触发后，GPU 开始渲染

**触发时机**：
- VSync 信号由显示硬件发出，每秒 60 次（或 120 次，取决于设备）
- VSync 信号表示"屏幕准备好显示新的一帧"
- Render Server 收到 VSync 信号后，命令 GPU 开始渲染

**这个阶段发生了什么**：

1. **GPU 渲染管线（Rendering Pipeline）**

   GPU 按照固定的渲染管线处理每一帧：

   **阶段 1：顶点着色（Vertex Shading）**
   - 处理 Layer 的几何信息（position、bounds、transform）
   - 将 Layer 的顶点坐标转换到屏幕坐标系
   - 应用变换矩阵（transform）

   **阶段 2：图元装配（Primitive Assembly）**
   - 将顶点组装成图元（三角形、四边形等）
   - 确定哪些图元在屏幕可见区域内

   **阶段 3：光栅化（Rasterization）**
   - 将图元转换成像素片段（fragments）
   - 确定每个像素的颜色值

   **阶段 4：片段着色（Fragment Shading）**
   - 对每个像素片段进行着色
   - 如果有纹理（texture），从纹理中采样颜色
   - 应用视觉属性（backgroundColor、opacity 等）
   - 处理混合模式（blend mode）

   **阶段 5：片段处理（Fragment Processing）**
   - 深度测试（z-order）
   - 模板测试
   - 混合（blending）

   **阶段 6：写入 FrameBuffer**
   - 将渲染结果写入 FrameBuffer（帧缓冲区）
   - FrameBuffer 是 GPU 内存中的一块区域，存储最终要显示的图像

2. **双缓冲机制（Double Buffering）**

   - GPU 使用两个 FrameBuffer：
     - **Front Buffer**：当前显示在屏幕上的帧
     - **Back Buffer**：正在渲染的帧
   - GPU 在 Back Buffer 中渲染新帧
   - VSync 信号到来时，交换 Front Buffer 和 Back Buffer
   - 这样保证屏幕显示的是完整的帧，不会出现撕裂（tearing）

3. **VSync 信号的作用**

   - **同步渲染和显示**：确保 GPU 渲染完成后再显示
   - **防止撕裂**：在屏幕刷新间隙交换 Buffer
   - **控制帧率**：限制渲染频率，避免过度渲染

4. **显示到屏幕**

   - FrameBuffer 中的数据通过显示控制器（Display Controller）输出到屏幕
   - 屏幕硬件按照刷新率（60Hz 或 120Hz）逐行扫描显示
   - 最终用户看到渲染结果

**关键点**：
- GPU 渲染是并行处理的，非常高效
- VSync 信号保证渲染和显示同步
- 双缓冲机制防止画面撕裂
- 如果 GPU 渲染时间超过 16.67ms（60 FPS），会出现掉帧

**在我们的 UIButton 例子中**：
- GPU 渲染三个 Layer：
  - UIButton 自身的 Layer：根据 backgroundColor、cornerRadius 等属性渲染几何图形
  - UIImageView 的 Layer：从纹理采样，渲染图片
  - UILabel 的 Layer：从纹理采样，渲染文字
- 按照层级关系（z-order）混合，最终合成一帧
- 写入 FrameBuffer，等待 VSync 信号显示

**性能考虑**：
- **GPU 渲染瓶颈**：
  - 纹理大小（大纹理占用显存）
  - 视图混合（多个 Layer 混合需要更多计算）
  - 离屏渲染（off-screen rendering，需要额外的渲染 pass）
- **掉帧的原因**：
  - CPU 处理时间过长（Layout、Display 阶段）
  - GPU 渲染时间过长（复杂图形、大量混合）
  - 位图上传时间过长（大图片）

---
