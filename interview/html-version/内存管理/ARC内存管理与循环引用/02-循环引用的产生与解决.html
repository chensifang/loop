<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>什么情况下会产生循环引用？如何解决？</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="container">
        <h1>什么情况下会产生循环引用？如何解决？</h1>
        
        <h2>核心概念</h2>
        <p>循环引用是指两个或多个对象相互强引用，导致它们的引用计数永远无法降为 0，从而造成内存泄漏。</p>
        
        <h2>循环引用产生的场景</h2>
        <table>
            <thead>
                <tr>
                    <th>场景</th>
                    <th>描述</th>
                    <th>示例</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>对象相互引用</strong></td>
                    <td>两个对象互相强引用对方</td>
                    <td>Person ↔ Apartment</td>
                </tr>
                <tr>
                    <td><strong>闭包捕获 self</strong></td>
                    <td>闭包是对象属性，闭包内使用 self</td>
                    <td>ViewController → closure → ViewController</td>
                </tr>
                <tr>
                    <td><strong>代理模式</strong></td>
                    <td>如果 delegate 是强引用</td>
                    <td>ViewController → tableView → ViewController</td>
                </tr>
                <tr>
                    <td><strong>父子关系</strong></td>
                    <td>父子对象互相强引用</td>
                    <td>Parent ↔ Child</td>
                </tr>
            </tbody>
        </table>
        
        <h3>1. 对象之间的相互引用</h3>
        <p><strong>典型场景：</strong></p>
        <div class="code-block"><code><span class="keyword">class</span> <span class="type">Person</span> {
    <span class="keyword">var</span> apartment: <span class="type">Apartment</span>?
}

<span class="keyword">class</span> <span class="type">Apartment</span> {
    <span class="keyword">var</span> tenant: <span class="type">Person</span>?  <span class="comment">// 强引用 Person</span>
}

<span class="keyword">var</span> person: <span class="type">Person</span>? = <span class="type">Person</span>()
<span class="keyword">var</span> apartment: <span class="type">Apartment</span>? = <span class="type">Apartment</span>()

person?.apartment = apartment  <span class="comment">// Person 强引用 Apartment</span>
apartment?.tenant = person     <span class="comment">// Apartment 强引用 Person</span>

<span class="comment">// 此时引用计数：
// Person: 2 (person变量 + apartment.tenant)
// Apartment: 2 (apartment变量 + person.apartment)

person = nil      // Person 引用计数 = 1（apartment.tenant 还在引用）
apartment = nil   // Apartment 引用计数 = 1（person.apartment 还在引用）

// 两个对象都无法释放！内存泄漏！</span></code></div>
        <div class="analogy">
            <p><strong>通俗理解：</strong></p>
            <p>就像两个人互相拉着对方的手，谁也不肯先松手，结果两个人都走不了。</p>
        </div>
        
        <h3>2. 闭包捕获 self</h3>
        <p><strong>典型场景：</strong></p>
        <div class="code-block"><code><span class="keyword">class</span> <span class="type">ViewController</span> {
    <span class="keyword">var</span> completionHandler: (() -&gt; <span class="type">Void</span>)?
    
    <span class="keyword">func</span> setup() {
        completionHandler = {
            <span class="keyword">self</span>.doSomething()  <span class="comment">// 闭包强引用 self</span>
        }
    }
    
    <span class="keyword">func</span> doSomething() {
        <span class="function">print</span>(<span class="string">"doing something"</span>)
    }
}

<span class="keyword">var</span> vc: <span class="type">ViewController</span>? = <span class="type">ViewController</span>()
vc?.setup()

<span class="comment">// 此时：
// ViewController 强引用 completionHandler（闭包）
// 闭包强引用 ViewController（self）

vc = nil  // ViewController 引用计数 = 1（闭包还在引用），无法释放！</span></code></div>
        <p><strong>为什么会这样？</strong></p>
        <p>闭包会捕获它内部使用的所有外部变量，如果闭包是对象的属性，而闭包内部又使用了 <code class="highlight">self</code>，就会形成循环引用。</p>
        
        <h3>3. 代理模式（Delegate）中的循环引用</h3>
        <p><strong>典型场景：</strong></p>
        <div class="code-block"><code><span class="keyword">class</span> <span class="type">ViewController</span> {
    <span class="keyword">var</span> tableView: <span class="type">UITableView</span>?
    
    <span class="keyword">init</span>() {
        tableView = <span class="type">UITableView</span>()
        tableView?.delegate = <span class="keyword">self</span>  <span class="comment">// 如果 delegate 是强引用，就会循环引用</span>
    }
}

<span class="comment">// 如果 UITableView 的 delegate 属性是强引用：
// ViewController 强引用 tableView
// tableView 强引用 ViewController（delegate）
// 形成循环引用</span></code></div>
        <div class="warning">
            <strong>注意：</strong> 实际上 <code class="highlight">UITableView.delegate</code> 是 <code class="highlight">weak</code> 引用，所以不会循环引用。但如果自己实现代理模式时用强引用，就会出问题。
        </div>
        
        <h3>4. 父子关系中的循环引用</h3>
        <p><strong>典型场景：</strong></p>
        <div class="code-block"><code><span class="keyword">class</span> <span class="type">Parent</span> {
    <span class="keyword">var</span> children: [<span class="type">Child</span>] = []
}

<span class="keyword">class</span> <span class="type">Child</span> {
    <span class="keyword">var</span> parent: <span class="type">Parent</span>?  <span class="comment">// 如果这里是强引用</span>
}

<span class="keyword">var</span> parent = <span class="type">Parent</span>()
<span class="keyword">var</span> child = <span class="type">Child</span>()
parent.children.append(child)
child.parent = parent  <span class="comment">// 如果 parent 是强引用，就会循环引用</span></code></div>
        <h2>如何解决循环引用</h2>
        <table>
            <thead>
                <tr>
                    <th>方法</th>
                    <th>特点</th>
                    <th>使用场景</th>
                    <th>注意事项</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>weak</strong></td>
                    <td>不增加引用计数，对象释放时自动置为 nil</td>
                    <td>不确定生命周期、代理模式、父子关系</td>
                    <td>必须是可选类型</td>
                </tr>
                <tr>
                    <td><strong>unowned</strong></td>
                    <td>不增加引用计数，不会自动置为 nil</td>
                    <td>确定被引用对象生命周期更长</td>
                    <td>对象释放后访问会崩溃</td>
                </tr>
                <tr>
                    <td><strong>捕获列表</strong></td>
                    <td>闭包中使用 <code class="highlight">[weak self]</code> 或 <code class="highlight">[unowned self]</code></td>
                    <td>闭包捕获 self 的场景</td>
                    <td>优先使用 weak</td>
                </tr>
                <tr>
                    <td><strong>手动断开</strong></td>
                    <td>在 deinit 中手动置为 nil</td>
                    <td>对象生命周期明确</td>
                    <td>不是最佳实践</td>
                </tr>
            </tbody>
        </table>
        
        <p><strong>对象释放的本质：</strong></p>
        <ul>
            <li>对象存储在<strong>堆内存</strong>中，有一个具体的<strong>内存地址</strong>（比如 0x1000）</li>
            <li>强引用变量（如 <code class="highlight">var person: Person?</code>）存储的是这个对象的<strong>内存地址</strong>（指针）</li>
            <li><strong>对象释放</strong> = 堆内存中这块地址（0x1000）的数据被清空/回收，这块内存可以被其他对象使用</li>
        </ul>
        
        <p><strong>weak 引用自动置为 nil 的本质：</strong></p>
        <ul>
            <li><code class="highlight">weak var tenant: Person?</code> 这个变量本身也占用内存，存储的是一个<strong>地址值</strong>（指针）</li>
            <li>当对象存在时，<code class="highlight">tenant</code> 变量存储的是对象的地址（比如 0x1000）</li>
            <li><strong>weak 置为 nil</strong> = 将 <code class="highlight">tenant</code> 变量存储的地址值从 <code class="highlight">0x1000</code> 改为 <code class="highlight">nil</code>（0x0），也就是<strong>清空指针</strong></li>
            <li>这样即使对象的堆内存被回收了，weak 变量也不会指向无效的内存地址</li>
        </ul>
        
        <h2>关键点总结</h2>
        <table>
            <thead>
                <tr>
                    <th>方面</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>本质</strong></td>
                    <td>对象相互强引用，引用计数无法降为 0</td>
                </tr>
                <tr>
                    <td><strong>常见场景</strong></td>
                    <td>对象相互引用、闭包捕获 self、代理模式、父子关系</td>
                </tr>
                <tr>
                    <td><strong>解决方法</strong></td>
                    <td>weak、unowned、捕获列表、手动断开</td>
                </tr>
                <tr>
                    <td><strong>选择原则</strong></td>
                    <td>不确定生命周期用 weak，确定生命周期用 unowned，闭包用捕获列表</td>
                </tr>
                <tr>
                    <td><strong>weak/unowned 区别</strong></td>
                    <td>详见问题 3：weak 和 unowned 的区别和使用场景</td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>
