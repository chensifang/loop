<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1. 简述 ARC（自动引用计数）的工作原理</title>
    <link rel="stylesheet" href="../../style.css">
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true });
    </script>
</head>
<body>
    <div class="container">
        <h1>1. 简述 ARC（自动引用计数）的工作原理</h1>
        
        <h2>核心概念</h2>
        <p>ARC 是编译器在编译时自动插入内存管理代码（retain/release），开发者无需手动管理对象生命周期。</p>
        
        <h2>工作原理</h2>
        
        <h3>1. 编译时自动插入代码</h3>
        <p>ARC 在编译时分析代码，在需要的地方自动插入 <code class="highlight">retain</code> 和 <code class="highlight">release</code>：</p>
        <div class="code-block"><code><span class="comment">// 你写的代码</span>
<span class="keyword">let</span> person = <span class="type">Person</span>()
<span class="keyword">let</span> name = person.name

<span class="comment">// ARC 编译后实际生成的代码（简化示意）</span>
<span class="keyword">let</span> person = <span class="type">Person</span>()
<span class="function">objc_retain</span>(person)  <span class="comment">// ARC 自动插入</span>
<span class="keyword">let</span> name = person.name
<span class="function">objc_release</span>(person)  <span class="comment">// ARC 自动插入（当 person 不再使用时）</span></code></div>
                <h3>2. 引用计数机制</h3>
        <table>
            <thead>
                <tr>
                    <th>操作</th>
                    <th>引用计数变化</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>对象创建</strong></td>
                    <td>+1</td>
                    <td>创建对象时自动 retain</td>
                </tr>
                <tr>
                    <td><strong>强引用赋值</strong></td>
                    <td>+1</td>
                    <td>赋值给强引用变量时 retain</td>
                </tr>
                <tr>
                    <td><strong>引用移除</strong></td>
                    <td>-1</td>
                    <td>强引用置为 nil 或离开作用域时 release</td>
                </tr>
                <tr>
                    <td><strong>计数为 0</strong></td>
                    <td>释放对象</td>
                    <td>所有强引用都移除后，对象被释放</td>
                </tr>
            </tbody>
        </table>
        
        <h3>3. 编译器如何判断插入位置</h3>
        <table>
            <thead>
                <tr>
                    <th>时机</th>
                    <th>插入的操作</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>对象创建时</strong></td>
                    <td><code class="highlight">retain</code></td>
                    <td>创建对象后立即增加引用计数</td>
                </tr>
                <tr>
                    <td><strong>赋值给强引用时</strong></td>
                    <td><code class="highlight">retain</code></td>
                    <td>新的强引用指向对象时</td>
                </tr>
                <tr>
                    <td><strong>强引用置为 nil 时</strong></td>
                    <td><code class="highlight">release</code></td>
                    <td>强引用被清空时</td>
                </tr>
                <tr>
                    <td><strong>离开作用域时</strong></td>
                    <td><code class="highlight">release</code></td>
                    <td>变量离开作用域时自动释放</td>
                </tr>
            </tbody>
        </table>
        
        <h2>通俗理解</h2>
        <div class="analogy">
            <p>就像图书馆借书系统：</p>
            <ul>
                <li>借书时登记（retain，计数+1）</li>
                <li>还书时注销（release，计数-1）</li>
                <li>没人借时，书被回收（计数为 0，对象释放）</li>
            </ul>
            <p>ARC 会自动完成这些登记和注销，你不需要手动写 <code class="highlight">retain</code>/<code class="highlight">release</code>。</p>
        </div>
        
        <h3>引用计数流程图</h3>
        <pre class="mermaid">
graph TD
    A[创建对象] --> B[引用计数 = 1]
    B --> C{有新的强引用?}
    C -->|是| D[引用计数 +1]
    C -->|否| E{引用计数 = 0?}
    D --> C
    E -->|是| F[释放对象]
    E -->|否| G[对象继续存在]
        </pre>
        
        <h2>实际例子</h2>
        <div class="code-block"><code><span class="keyword">class</span> <span class="type">Person</span> {
    <span class="keyword">var</span> name: <span class="type">String</span>
    <span class="keyword">init</span>(name: <span class="type">String</span>) {
        <span class="keyword">self</span>.name = name
    }
}

<span class="keyword">func</span> example() {
    <span class="keyword">let</span> person1 = <span class="type">Person</span>(name: <span class="string">"张三"</span>)  <span class="comment">// 引用计数 = 1</span>
    <span class="keyword">let</span> person2 = person1              <span class="comment">// 引用计数 = 2（person2 也引用了）</span>
    
    <span class="comment">// person1 离开作用域，引用计数 = 1</span>
    <span class="comment">// person2 离开作用域，引用计数 = 0，对象被释放</span>
}</code></div>
                <h2>关键点</h2>
        <table>
            <thead>
                <tr>
                    <th>特性</th>
                    <th>说明</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>编译时特性</strong></td>
                    <td>在编译阶段插入代码，运行时没有额外开销</td>
                </tr>
                <tr>
                    <td><strong>只管理对象</strong></td>
                    <td>值类型（struct、enum）不受 ARC 管理</td>
                </tr>
                <tr>
                    <td><strong>循环引用</strong></td>
                    <td>需要手动处理，使用 <code class="highlight">weak</code> 或 <code class="highlight">unowned</code> 打破循环</td>
                </tr>
            </tbody>
        </table>
        
        <h2>ARC vs MRC（手动管理）</h2>
        <table>
            <thead>
                <tr>
                    <th>方面</th>
                    <th>MRC（手动管理）</th>
                    <th>ARC（自动管理）</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>代码</strong></td>
                    <td>需要手动写 <code class="highlight">retain</code>/<code class="highlight">release</code></td>
                    <td>编译器自动插入</td>
                </tr>
                <tr>
                    <td><strong>示例</strong></td>
                    <td><code class="highlight">[person retain]; [person release];</code></td>
                    <td><code class="highlight">let person = Person()</code></td>
                </tr>
                <tr>
                    <td><strong>错误率</strong></td>
                    <td>容易出错（忘记 release 导致泄漏）</td>
                    <td>减少内存管理错误</td>
                </tr>
                <tr>
                    <td><strong>性能</strong></td>
                    <td>手动控制</td>
                    <td>编译时优化，性能相同</td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>
